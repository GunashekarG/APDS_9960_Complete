/**
 *  @file
 *
 *  @brief      Hardware Baseline for the HMI.
 *
 *  @details    Manages the initialization and handlers for the low level inputs and generic inputs for the HMI.
 *              Provides interface to manipulate view objects (LEDs) and sounds.
 *              NOTE: For a P1 system, Hbl module must be initialized before this module.
 *
 *  @defgroup   CLASS_B

 *  @copyright  Copyright 2015-2017: 2017/08/04 13:04:23EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
 */
//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------

//-------------------------------------- Include Files ----------------------------------------------------------------

#include "SRSystemConfig.h"
#include "SystemConfig.h"
#include "SRHblHmi.h"
#include "HblHmi.h"
#include "HblHmi_prv.h"
#include "HblDefs.h"

#include "Callback.h"
#include "Crc8.h"
#include "LedMgr.h"
#include "Log.h"
#include <math.h>
#include "Regulations.h"
#include "SettingFile.h"
#include "SRData.h"
#include "SRException.h"
#if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
    #include "SRTaskSequence.h"
#endif
#include <string.h>
#include "Utilities.h"
#include "ViewMgr.h"

//! The name of this module for use by the Log module.
#define MODULE_NAME MODULE_HBLHMI

//! A list of log message IDs that are generated by this module.
typedef enum MODULE_HBLHMI_LOG_MESSAGE_ID_ENUM
{
    UNSUPPORTED_GI_TYPE = 1,    // Data: Enum value of GI type coming from the setting file that is not supported by the firmware configuration
	INCORRECT_NUMBER_OF_GI_VIRTUAL
} MODULE_HBLHMI_LOG_MESSAGE_ID_TYPE;

//! define the callback control structure module static variable
DEFINE_CALLBACK_CONTROL_STRUCTURE(HblHmi_GI_Callback_Control_Structure, HBLHMI_GI_CALLBACK_REGISTER_SIZE);
DEFINE_CALLBACK_CONTROL_STRUCTURE(HblHmi_Sequence_Callback_Control_Structure, 1);   // Size of register intentionally hard coded to 1

//-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------
#define NO_PARAMETER_OFFSET  0xFF   //! Value in setting file for the offset to the parameter data when an LLI has no parameters

#define NUM_BYTES_LLI_MAP    4      //! Number of bytes in the setting file data for a LLI configuration
#define NUM_BYTES_GI_MAP     6      //! Number of bytes in the setting file data for a GI configuration

//------- LowLeveL Inputs Data -------
static uint8 HblHmi_LLI_Sequence_Num[HBLHMI_MAX_NUM_LLI];
static uint8 N_HblHmi_LLI_Sequence_Num[HBLHMI_MAX_NUM_LLI];

//------- Generic Inputs Data -------
#if (HBL_GI_NUM_ANALOG_POTENTIOMETER > 0) || (HBL_GI_NUM_DISCRETE_POTENTIOMETER > 0) || (HBL_GI_NUM_TOUCH_SLIDER > 0) || (HBL_GI_NUM_TOUCH_WHEEL > 0)
    static ANALOGGI_DATA_TYPE HblHmi_Virtual_GI_Analog_Buffer[HBLHMI_VIRTUAL_GI_ANALOG_BUFFER_SIZE];
#endif
#if (HBL_GI_NUM_KEY > 0) || (HBL_GI_NUM_SRKEY > 0)
    static KEYGI_DATA_TYPE HblHmi_Virtual_GI_Digital_Buffer[HBLHMI_VIRTUAL_GI_DIGITAL_BUFFER_SIZE];
#endif
#if ((HBL_GI_NUM_INCREMENTAL_ENCODER > 0) || (HBL_GI_NUM_ABSOLUTE_ENCODER > 0))
    static ENCGI_DATA_TYPE HblHmi_Virtual_GI_Encoder_Buffer[HBLHMI_VIRTUAL_GI_ENCODER_BUFFER_SIZE];
#endif

static uint8 HblHmi_GI_Sequence_Num[HBLHMI_MAX_NUM_GI];
static uint8 N_HblHmi_GI_Sequence_Num[HBLHMI_MAX_NUM_GI];

//------- Low Level Input Management ------------------------------------------------
static HBL_LLI_TYPE HblHmi_Lli_Cfg[HBLHMI_MAX_NUM_LLI];
static uint8 HblHmi_Lli_Cfg_Crc[HBLHMI_MAX_NUM_LLI];
static uint8 HblHmi_Num_Lli;
static uint8 N_HblHmi_Num_Lli;  //!< Inverted memory for the Class B variable

#define HBLHMI_NUM_LLI_HANDLERS  (sizeof(HBLHMI_LLI_HANDLERS) / sizeof(HBL_LLI_HANDLER_HOOK_TYPE))

//------- Generic Input Management ------------------------------------------------
static HBLHMI_GI_TYPE HblHmi_Gi_Cfg[HBLHMI_MAX_NUM_GI];
static uint8 HblHmi_Gi_Cfg_Crc[HBLHMI_MAX_NUM_GI];

static struct {
    uint8 Digital;
    uint8 Analog;
    uint8 Encoder;
}HblHmi_Num_GI; //! Number of GIs by read type
static uint8 HblHmi_Num_Total_GI;
static uint8 N_HblHmi_Num_Total_GI;     //!< Inverted memory for the Class B variable
#define CONFIG_INDEX_VIRTUAL_GI 0xFF    //!<Index of GI configuration buffer for virtual GIs (they don't have an index value)
#define HBLHMI_NUM_GI_HANDLERS  (sizeof(HBLHMI_GI_HANDLERS) / sizeof(HBLHMI_GI_HANDLER_HOOK_TYPE))

//------- LEDs Management

#if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
	//! Calculates the number of bytes used to store the LED mask
	#define LED_MASK_SIZE	NUM_OF_LEDS / 8 + 1
	static uint8 LedPriorityBuffer[HBLHMI_LED_PRIORITY_MAX][LED_MASK_SIZE];	// This generates a compile error if feature is enabled and HBLHMI_LED_PRIORITY_MAX is 0
#endif

//! Feature to enable a separate function to call the method to process the LLIs and GIs
#ifndef HBLHMI_MAIN_HANDLER
    #define HBLHMI_MAIN_HANDLER DISABLED
#endif

//-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
static void * GetVirtualGiBufferPtr(HBLHMI_GI_READ_TYPE read_type, uint8 gi_position);
static uint8 GetGiHandler(HBLHMI_GI_ENUM_TYPE generic_input);
static uint8 GetLliHandler(HBL_LLI_ENUM_TYPE input);
static void  GIEventHandler(HBLHMI_GI_EVENT_TYPE gi_event);
static void  GiInitialize(void);
static void  LliInitialize(void);
static void  UpdateLLISequence(uint8 index);
static void  UpdateGISequence(uint8 index);
//=====================================================================================================================
//-------------------------------------- Public Functions -------------------------------------------------------------
//=====================================================================================================================

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Initialization for the module.
 * @details NOTE: For a P1 system, Hbl module must be initialized before this module
 */
void HblHmi__Initialize(void)
{
    #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
        SRTaskSequence__SetSequenceStep(SRTASKSEQUENCE_APPL_SAFETY_INIT, SRTASKSEQUENCE_APPL_INIT_HBLHMI_INITIALIZE);
    #endif
    LliInitialize();
    GiInitialize();
    ViewMgr__Initialize();
    Callback__Initialize(&HblHmi_GI_Callback_Control_Structure);
    Callback__Initialize(&HblHmi_Sequence_Callback_Control_Structure);
    HBLHMI__REGISTERGIEVENTHANDLER(&GIEventHandler);    //lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

    #if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
        memset(LedPriorityBuffer, 0, sizeof(LedPriorityBuffer));
    #endif
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief       Handler to be executed in the Main thread
 * @details     If the location to call this method is not available it can also be called from asynchronous thread.
 */
void HblHmi__MainHandler(void)
{
    uint8 index;
        uint8 idx;
        uint8 idx_lli;
        uint8 * lli_data_ptr = NULL;

        //---------------------------- Low Level Input Management ---------------------------------------------------------
        for (index = 0; index < HblHmi_Num_Lli; index++)
        {
            if (HblHmi_Lli_Cfg[index].LLI_Handler_Index < HBLHMI_NUM_LLI_HANDLERS)
            {
                if (HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].AsynchProcess != NULL)
                {
                    if (HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].AsynchProcess(&HblHmi_Lli_Cfg[index]) == TRUE)
                    {
                        UpdateLLISequence(index);
                    }
                }
            }
        }

        //---------------------------- Generic Input Management -----------------------------------------------------------
        for (index = 0; index < HblHmi_Num_Total_GI; index++)
        {
            idx = HblHmi_Gi_Cfg[index].GI_Handler_Index;
            idx_lli = GetLliHandler(HblHmi_Gi_Cfg[index].LLI_ID);

            // If the low level input exists (not virtual), grab the pointer to the data for that low level input so it can be consumed by the generic input
            if ((HblHmi_Gi_Cfg[index].LLI_Config_Index < HBLHMI_MAX_NUM_LLI) &&
                (idx_lli < HBLHMI_NUM_LLI_HANDLERS))
            {
                lli_data_ptr = HblHmi__GetLLIDataByIndex(HblHmi_Gi_Cfg[index].LLI_Config_Index);
            }

            if (idx < HBLHMI_NUM_GI_HANDLERS)
            {
                if (HBLHMI_GI_HANDLERS[idx].AsynchProcess != NULL &&
                    lli_data_ptr != NULL)
                {
                    if (HBLHMI_GI_HANDLERS[idx].AsynchProcess(&HblHmi_Gi_Cfg[index],lli_data_ptr, HblHmi_LLI_Sequence_Num [HblHmi_Gi_Cfg[index].LLI_Config_Index]) == TRUE)
                    {
                        UpdateGISequence(index);
                    }
                }
            }
        }

}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief Handler to be executed once every 5 milliseconds.
 */
void HblHmi__AsynchHandler(void)
{
#if (HBLHMI_MAIN_HANDLER == DISABLED)
    HblHmi__MainHandler();
#endif

    ViewMgr__Handler5ms();
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Tasks to be executed every 1ms
 */
void HblHmi__Handler1ms(void)
{
    ViewMgr__Handler1ms();
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Tasks to be executed in AppMgr thread.
 *          To avoid flickering should be executed just after HmiApplianceMgr__Handler (or any other further handler which can try to change LEDs state).
 */
void HblHmi__Handler(void)
{
#if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
    HblHmi__ApplyNonAnimationsBuffer();
#endif
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Registers a GI event handler with the module.
 * @param   event_handler: pointer to the function that handles the event
 */
void HblHmi__RegisterGIEventHandler(HBLHMI_GI_EVENT_HANDLER_TYPE event_handler)
{
    Callback__Register(&HblHmi_GI_Callback_Control_Structure, (CALLBACK_HANDLER_TYPE)event_handler);    //lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Unregisters a GI event handler with the module.
 * @param   event_handler: pointer to the function that handles the event
 */
void HblHmi__UnregisterGIEventHandler(HBLHMI_GI_EVENT_HANDLER_TYPE event_handler)
{
    Callback__Unregister(&HblHmi_GI_Callback_Control_Structure, (CALLBACK_HANDLER_TYPE)event_handler);  //lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Registers an event handler for Sequences with the module.
 * @param   event_handler: pointer to the function that handles the event
 */
void HblHmi__RegisterSequenceHandler(HBLHMI_GI_EVENT_HANDLER_TYPE event_handler)
{
    Callback__Register(&HblHmi_Sequence_Callback_Control_Structure, (CALLBACK_HANDLER_TYPE)event_handler);  //lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Unregisters an event handler for Sequences with the module.
 * @param   event_handler: pointer to the function that handles the event
 */
void HblHmi__UnregisterSequenceHandler(HBLHMI_GI_EVENT_HANDLER_TYPE event_handler)
{
    Callback__Unregister(&HblHmi_Sequence_Callback_Control_Structure, (CALLBACK_HANDLER_TYPE)event_handler);    //lint !e929 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param   read_type: See HBLHMI_GI_READ_TYPE
 * @param   gi_position
 * @return  GI configuration if the GI is real, else NULL (Covers case for requesting GI configuration for a virtual GI,
 *          which has no GI configuration in the setting file)
 */
HBLHMI_GI_TYPE * HblHmi__GetGITypeByGidata(HBLHMI_GI_READ_TYPE read_type, uint8 gi_position)
{
    uint8 gi_config_index;

    gi_config_index = HblHmi__GetGIConfigIndexByType(read_type, gi_position);

    if (gi_config_index != CONFIG_INDEX_VIRTUAL_GI)
    {
        return(&HblHmi_Gi_Cfg[gi_config_index]);
    }
    else
    {
        return(NULL);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Get the current value of a GI based on the index in the GI configuration data
 * @details This function does not support Virtual GIs since they do not have GI configuration data in the setting file
 *          and therefore do not have an index in the GI configuration data
 * @param   index: index of the GI in the GI configuration data
 */
void * HblHmi__GetGIByIndex(uint8 index)
{
    void * retval;
    void * lli_data;

    retval = NULL;
    if (index < HblHmi_Num_Total_GI)
    {
        if (HblHmi_Gi_Cfg[index].GI_Handler_Index < HBLHMI_NUM_GI_HANDLERS)
        {
            if (HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].Get != NULL)
            {
                lli_data = HblHmi__GetLLIDataByIndex(HblHmi_Gi_Cfg[index].LLI_Config_Index);
                retval = HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].Get(&HblHmi_Gi_Cfg[index], lli_data);
            }
        }
    }
   return (retval);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param read_type
 * @param gi_position
 * @return
 */
void * HblHmi__GetGIData(HBLHMI_GI_READ_TYPE read_type, uint8 gi_position)  // GetGIDataByType
{
    void * retval;
    void * lli_data;
    uint8 gi_config_index;

    retval = NULL;

    gi_config_index = HblHmi__GetGIConfigIndexByType(read_type, gi_position);

    if (gi_config_index != CONFIG_INDEX_VIRTUAL_GI)
    {
        if (HblHmi_Gi_Cfg[gi_config_index].GI_Handler_Index < HBLHMI_NUM_GI_HANDLERS)
        {
            if (HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[gi_config_index].GI_Handler_Index].Get != NULL)
            {
                lli_data = HblHmi__GetLLIDataByIndex(HblHmi_Gi_Cfg[gi_config_index].LLI_Config_Index);
                retval = HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[gi_config_index].GI_Handler_Index].Get(&HblHmi_Gi_Cfg[gi_config_index], lli_data);
            }
        }
    }
    else
    {
        retval = GetVirtualGiBufferPtr(read_type, gi_position);
    }

    return(retval);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief
 * @details This function does not support Virtual GIs since they do not have GI configuration data in the setting file
 *          and therefore do not have an index in the GI configuration data
 * @param   index: index of the GI in the GI configuration data
 * @return
 */
uint8 HblHmi__GetGIDataSizeByIndex(uint8 index)
{
    if ((index < HblHmi_Num_Total_GI) &&
        (HblHmi_Gi_Cfg[index].GI_Handler_Index < HBLHMI_NUM_GI_HANDLERS))
    {
        return (HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].Parameter_Size);
    }
    else
    {
        return (0);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Returns the index in HblHmi_Gi_Cfg buffer for the GI
 * @param   read_type: See HBLHMI_GI_READ_TYPE
 * @param   position
 * @return  If found, returns the index of the GI in the GI configuration buffer, else 0xFF
 */
uint8 HblHmi__GetGIConfigIndexByType(HBLHMI_GI_READ_TYPE read_type, uint8 position)
{
    uint8 gi_config_index = CONFIG_INDEX_VIRTUAL_GI;    // Initialize to invalid index

    for (uint8 index = 0; index < HblHmi_Num_Total_GI; index++)
    {
        if ((HblHmi_Gi_Cfg[index].GI_Read_Type == read_type) &&
            (HblHmi_Gi_Cfg[index].GI_Position == position))
        {
            gi_config_index = index;
            break;
        }
    }

    return(gi_config_index);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief
 * @details This function does not support Virtual GIs since they do not have GI configuration data in the setting file
 *          and therefore do not have an index in the GI configuration data
 * @param   index: index of the GI in the GI configuration data
 * @return
 */
HBLHMI_GI_ENUM_TYPE HblHmi__GetGIIDByIndex(uint8 index)
{
    if (index < HblHmi_Num_Total_GI)
    {
        return (HblHmi_Gi_Cfg[index].GI_ID);
    }
    else
    {
        return (HBLHMI_GI_INVALID);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief Returns the read type of a given GI index
 * @param index: index of the GI in the GI configuration data
 * @return
 */
uint8 HblHmi__GetGIReadTypeByIndex(uint8 index)
{
    if (index < HblHmi_Num_Total_GI)
    {
        return (HblHmi_Gi_Cfg[index].GI_Read_Type);
    }
    else
    {
        return (HBLHMI_GI_INVALID);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief Returns the read type of a given GI index
 * @param index: index of the GI in the GI configuration data
 * @return
 */
uint8 HblHmi__GetGIPositionByIndex(uint8 index)
{
    if (index < HblHmi_Num_Total_GI)
    {
        return (HblHmi_Gi_Cfg[index].GI_Position);
    }
    else
    {
        return (HBLHMI_GI_INVALID);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief
 * @param input
 * @return
 */
HBL_LLI_ENUM_TYPE HblHmi__GetLLIIDByIndex(uint8 input)
{
    if (input < HblHmi_Num_Lli)
    {
        return (HblHmi_Lli_Cfg[input].LLI_ID);
    }
    else
    {
        return (HBL_LLI_INVALID);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param lli_id
 * @param position
 * @return
 */
uint8 HblHmi__GetLLIIndexByID(HBL_LLI_ENUM_TYPE lli_id, uint8 position)
{
    uint8 index;
    uint8 retval;

    retval = 0xFF;

    for (index = 0; index < HblHmi_Num_Lli; index++)
    {
        if ((HblHmi_Lli_Cfg[index].LLI_ID == lli_id) &&
            (HblHmi_Lli_Cfg[index].LLI_Position == position))
        {
            retval = index;
            break;
        }
    }
    return (retval);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param index
 */
void * HblHmi__GetLLIDataByIndex(uint8 index)
{
    uint8 * retval;
    retval = NULL;

    if (index < HblHmi_Num_Lli)
    {
        if ((HblHmi_Lli_Cfg[index].LLI_Handler_Index < HBLHMI_NUM_LLI_HANDLERS) &&
            (HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].Get != NULL) )
        {
            retval = HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].Get(&HblHmi_Lli_Cfg[index]);
        }
    }

    return (retval);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param index
 * @return
 */
uint8 HblHmi__GetLLIDataSizeByIndex(uint8 index)
{
    uint8 idx;
    uint8 size;

    size = 0;
    if (index < HblHmi_Num_Lli)
    {
        idx = HblHmi_Lli_Cfg[index].LLI_Handler_Index;
        if (idx != HBL_INDEX_INVALID)
        {
            size = (HBLHMI_LLI_HANDLERS[idx].Parameter_Size);
        }
    }

    return(size);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief This method returns the LLI position by LLI index.
 * @param index
 * @return LLI Position, 0255 if not valid.
 */
uint8 HblHmi__GetLLIPositionByIndex(uint8 index)
{
    if (index < HblHmi_Num_Lli)
    {
        return (HblHmi_Lli_Cfg[index].LLI_Position);
    }
    else
    {
        return (HBL_INDEX_INVALID);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief This method returns LLI ID by GI Index.
 * @param index GI Index
 * @return LLI ID , 0xFF if not valid.
 */
HBL_LLI_ENUM_TYPE HblHmi__GetLLIIDByGIIndex(uint8 index)
{
    if (index < HblHmi_Num_Total_GI)
    {
        return (HblHmi_Gi_Cfg[index].LLI_ID);
    }
    else
    {
        return (HBL_LLI_INVALID);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief This method returns LLI Position by GI Index.
 * @param index GI Index
 * @return LLI Position , 0xFF if not valid.
 */
uint8 HblHmi__GetLLIPositionByGIIndex(uint8 index)
{
    uint8 lli_position;

    lli_position = HBL_INDEX_INVALID;

    if (index < HblHmi_Num_Total_GI)
    {
        lli_position = HblHmi_Gi_Cfg[index].LLI_position;
    }

    return (lli_position);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Returns the total number of Generic Inputs
 */
uint8 HblHmi__GetNumGI(void)
{
    return (HblHmi_Num_Total_GI);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Returns the number of Generic Inputs with a given read type
 * @param   read_type: See HBLHMI_GI_READ_TYPE
 * @return  Number of Generic Inputs with the given read type
 */
uint8 HblHmi__GetNumGIReadType(HBLHMI_GI_READ_TYPE read_type)
{
    uint8 num_read_type;
    uint8 index;

    num_read_type = 0;

    for (index = 0; index < HblHmi_Num_Total_GI; index++)
    {
        if (HblHmi_Gi_Cfg[index].GI_Read_Type == read_type)
        {
            num_read_type++;
        }
    }

    return(num_read_type);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Returns the total number of Low Level Inputs
 */
uint8 HblHmi__GetNumLLI(void)
{
    return (HblHmi_Num_Lli);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief This method returns LLI Sequence ID by LLI Index.
 * @param index
 * @return LLI Sequence ID, 0 if invalid.
 */
uint8 HblHmi__GetLLISequenceIDByIndex(uint8 index)
{
    uint8 seq_id;

    seq_id = 0;

    if (index < HblHmi_Num_Lli)
    {
        seq_id = HblHmi_LLI_Sequence_Num[index];
    }

    return(seq_id);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Sets the value of a generic input. This function is currently designed to only be called for setting the
 *          resulting generic input of a Sequence since the value is reset at the end of the function.
 *
 * @param   read_type: See HBLHMI_GI_READ_TYPE
 * @param   position: Position of the GI
 * @param   value: desired value of the GI
 */
void HblHmi__SetGI(HBLHMI_GI_READ_TYPE read_type, uint8 position, uint8 value)
{
    CALLBACK_EVENT_TYPE event;
    uint8 gi_config_index;

    // Setup event for the callback
    event = position;
    event = event | ((read_type) << 6);

    // Get index in GI configuration buffer
    gi_config_index = HblHmi__GetGIConfigIndexByType(read_type, position);

    // Check if GI is real or virtual
    if (gi_config_index != CONFIG_INDEX_VIRTUAL_GI)     // GI is real
    {
        if (HblHmi_Gi_Cfg[gi_config_index].GI_Handler_Index < HBLHMI_NUM_GI_HANDLERS)
        {
            HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[gi_config_index].GI_Handler_Index].Set(&HblHmi_Gi_Cfg[gi_config_index], value);
        }
    }
    else    // GI is virtual
    {
        HblHmi__SetVirtualGiBuffer(read_type, position, value);
        Callback__Notify(&HblHmi_GI_Callback_Control_Structure, event);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief This method returns GI Sequence ID by GI Index.
 * @param index
 * @return GI Sequence ID, 0 if invalid.
 */
uint8 HblHmi__GetGISequenceIDByIndex(uint8 index)
{
    uint8 seq_id;

    seq_id = 0;

    if (index < HblHmi_Num_Total_GI)
    {
        seq_id = HblHmi_GI_Sequence_Num[index];
    }

    return(seq_id);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Clears the current content displayed on the View. This provides a clean slate to apply new content on the View.
 */
void HblHmi__ClearView(void)
{
    ViewMgr__ClearView();
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Displays a fault to the user
 * @param   f_code
 * @param   e_code
 * @param   eng_code
 */
void HblHmi__DisplayFault(uint8 f_code, uint8 e_code, uint8 eng_code)
{
    ViewMgr__DisplayFault(f_code, e_code, eng_code);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Plays a sound.
 * @param   sound_index: Index that points to the data for the sound to play; Corresponds to the displacement in the audio configuration pointer
 * @param   volume_index: level of volume to play the sound; See SOUND_VOLUME_TYPE
 * @param   sound_priority: the priority level for this sound (only used when there is a sound queue)
 * @param   keep_previous: determines if the currently playing sound should be replayed after the higher priority sound finishes (only used when there is a sound queue)
 */
void HblHmi__PlaySoundComplex(uint8 sound_index, SOUND_VOLUME_TYPE volume_index, SOUND_PRIORITY_TYPE sound_priority, BOOL_TYPE keep_previous)
{
    ViewMgr__PlaySound(sound_index, volume_index, sound_priority, keep_previous);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Plays a sound.
 * @param   sound_index: Index that points to the data for the sound to play; Corresponds to the displacement in the audio configuration pointer
 * @param   volume_index: level of volume to play the sound; See SOUND_VOLUME_TYPE
 */
void HblHmi__PlaySoundSimple(uint8 sound_index, SOUND_VOLUME_TYPE volume_index)
{
    ViewMgr__PlaySound(sound_index, volume_index, DEFAULT_SOUND_PRIORITY, FALSE);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Sets a graphical object.
 * @param   object_type: See VISUAL_OBJECT_TYPE.
 * @param   object_index: Depends on the object_type.
                          If object_type is LED, BAR or DIGIT, object_index is an index into the comprehensive list of LEDs and groups.
                          If object_type is STRING, object_index is an index into a group of strings.
 * @param   object_value: Depends on the object_type.
                          If object_type is LED, an object_value of 0 means the LED is off, else the LED is on.
                          If object_type is BAR, the object_value is a bit encoded binary number, where each bit represents an on(1)/off(0)
                            state of an object in the Bar.
                          If object_type is DIGIT, object_value is the ASCII code in decimal that represents the character to display.
                          If object_type is STRING, object_value is an index into the group of strings pointed to by the object_index.
   @param	object_intensity: Intensity to be applied to the object
   @param	priority_level : see HBLHMI_LED_PRIORITY_LEVEL_TYPE type
 */
void HblHmi__SetObject(VISUAL_OBJECT_TYPE object_type, uint16 object_index, uint32 object_value, uint8 object_intensity, HBLHMI_LED_PRIORITY_LEVEL_TYPE priority_level)
{
    HblHmi__SetObjectWithPWM(object_type, object_index, object_value, object_intensity, VIEWMGR_PWM_NONE, priority_level);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Sets a graphical object.
 * @param   object_type: See VISUAL_OBJECT_TYPE.
 * @param   object_index: Depends on the object_type.
                          If object_type is LED, BAR or DIGIT, object_index is an index into the comprehensive list of LEDs and groups.
                          If object_type is STRING, object_index is an index into a group of strings.
 * @param   object_value: Depends on the object_type.
                          If object_type is LED, an object_value of 0 means the LED is off, else the LED is on.
                          If object_type is BAR, the object_value is a bit encoded binary number, where each bit represents an on(1)/off(0)
                            state of an object in the Bar.
                          If object_type is DIGIT, object_value is the ASCII code in decimal that represents the character to display.
                          If object_type is STRING, object_value is an index into the group of strings pointed to by the object_index.
 * @param	object_intensity: Intensity to be applied to the object
 * @param   pwm_index
   @param	priority_level : see HBLHMI_LED_PRIORITY_LEVEL_TYPE type
 */
void HblHmi__SetObjectWithPWM(VISUAL_OBJECT_TYPE object_type, uint16 object_index, uint32 object_value, uint8 object_intensity, uint8 pwm_index, HBLHMI_LED_PRIORITY_LEVEL_TYPE priority_level)
{
#if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
    SETTINGFILE_LOADER_TYPE sf_loader;
//    uint32 led_group_pattern;
	uint8 priority_index;
	uint8 led_index;
	BOOL_TYPE call_viewmgr;

	led_index = 0;
//	led_group_pattern = object_value;
	call_viewmgr = TRUE;

    switch(object_type)
    {
        case VISUAL_OBJECT_LED:
    		//	Find LED bit in LedPriorityBuffer and check if a higher priority request has already been processed
        	for(priority_index = ((uint8)priority_level + 1); priority_index < HBLHMI_LED_PRIORITY_MAX; priority_index++)
        	{
        		if(Utilities__GetBitInArray(LedPriorityBuffer[priority_index], object_index) > 0)
        		{
        			call_viewmgr = FALSE;
        			break;
        		}
        	}
            break;
        case VISUAL_OBJECT_DIGIT:					// Digit object priority shall be evaluated for the whole LED group
//        	led_group_pattern = PATTERN_ALL;		//lint -fallthrough
        case VISUAL_OBJECT_BAR:
            //Verify that the group is in the valid range
            if ((object_index < LED_GROUP_NUM) &&
                (SettingFile__BasicLoader(SF_PTR_UI_LED_GROUP_CONFIGURATION, object_index, &sf_loader) == PASS))
            {
                for (led_index = 0; led_index < sf_loader.Length; led_index++)	// Scroll all the LEDs inside the group
                {
                    if (sf_loader.Data[led_index] != INVALID_LED_INDEX)	// Cover case where an extra led index was added for word alignment only
                    {
                    	/* Previously there was check if(((1 << led_index) & led_group_pattern) > 0) which was causing
                    	 * the issue when visual macro sets bar to all 0 (value = 0). Value is used as pattern for bar and
                    	 * if visual macro wanted to turn off all LEDS in the bar mechanism of priorities was not working.
                    	 * See Defect 954189.
                    	 */
                    	//	Find LED bit in LedPriorityBuffer and check if a higher priority request has already been processed
                    	for(priority_index = ((uint8)priority_level + 1); priority_index < HBLHMI_LED_PRIORITY_MAX; priority_index++)
                    	{
                    		if(Utilities__GetBitInArray(LedPriorityBuffer[priority_index], sf_loader.Data[led_index]) > 0)
                    		{
                    			call_viewmgr = FALSE;
                    			break;
                    		}
                    	}
                    }
                }
            }
            break;
        case VISUAL_OBJECT_STRING:
        case VISUAL_OBJECT_ICON:
            // Functionality not used for this HMI
        default:
            // Do nothing
            break;
    }

    if(call_viewmgr == TRUE)
    {
        ViewMgr__SetObject(object_type, object_index, object_value, object_intensity, pwm_index);
    }
#else
    ViewMgr__SetObject(object_type, object_index, object_value, object_intensity, pwm_index);
#endif

}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Set the desired volume to be used for all future sounds.
 * @param   volume_index: See SOUND_VOLUME_TYPE
 */
void HblHmi__SetVolume(SOUND_VOLUME_TYPE volume_index)
{
    ViewMgr__SetVolume(volume_index);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Stops displaying the fault that is currently being displayed (if applicable)
 */
void HblHmi__StopFaultDisplay(void)
{
    ViewMgr__StopFaultDisplay();
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Stops all sounds if any are playing
 */
void HblHmi__StopAllSound(void)
{
    ViewMgr__StopAllSound();
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Gets amount of LEDs inside the given led group
 *    @details 	This method returns the amount of LEDs inside the given led group
 *    @param 	led_group
 *    @return	ret_val: LEDs amount
 */
uint8 HblHmi__GetLedNumInGroup(uint16 led_group)
{
	return ViewMgr__GetLedNumInGroup(led_group);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param led_index
 * @return
 */
ON_OFF_TYPE HblHmi__GetLedState(uint16 led_index)
{
    return(ViewMgr__GetLedState(led_index));
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param group_index
 * @param member_index
 * @return
 */
ON_OFF_TYPE HblHmi__GetLedStateInGroup(uint16 group_index, uint8 member_index)
{
    return(ViewMgr__GetLedStateInGroup(group_index, member_index));
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Turn on a portion of an LED group
 *    @param 	led_group
 *    @param 	percentage
 *    @param 	inverse : invert the LEDs percentage direction
 */
void HblHmi__SetLedGroupPercentage(uint16 led_group, uint8 percentage, BOOL_TYPE inverse)
{
	HblHmi__SetLedGroupPercentageWithPWM(led_group, percentage, inverse, VIEWMGR_PWM_NONE);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Turn on a portion of an LED group
 *    @param 	led_group
 *    @param 	percentage
 *    @param 	inverse : invert the LEDs percentage direction
 *	  @param    pwm_index
 */
void HblHmi__SetLedGroupPercentageWithPWM(uint16 led_group, uint8 percentage, BOOL_TYPE inverse, uint8 pwm_index)
{
    float led_ratio;
	uint8 index;
	uint8 led_num;

	led_ratio = (float)percentage / 100;

	led_num = (uint8)ceil((float)HblHmi__GetLedNumInGroup(led_group) * led_ratio);

	if(inverse == FALSE)
	{
		for(index = 0; index < led_num; index++)
		{
			ViewMgr__ModifyLedInGroup(	 led_group,
					 	 	 	 	 	 index,
										 0xFF,
										 pwm_index);
		}
	}
	else
	{
		for(index = HblHmi__GetLedNumInGroup(led_group); index > 0; index--)
		{
			ViewMgr__ModifyLedInGroup(	 led_group,
					 	 	 	 	 	 index,
										 0xFF,
										 pwm_index);
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *  @brief      Sets an individual led without modifying other led's within the group
 *  @details    This function may modify led's beyond the maximum group size.
 *
 *  @param      group_index : The group to set
 *  @param      selected : the index of the member within the group which will be set to intensity
 *  @param      intensity : The intensity to apply to the modified led
 *  @param		priority_level: level of priority to be applied to the group
 */
void HblHmi__ModifyLedInGroup(uint16 group_index, uint8 selected, uint8 intensity, HBLHMI_LED_PRIORITY_LEVEL_TYPE priority_level)
{
	HblHmi__ModifyLedInGroupWithPWM(group_index, selected, intensity, VIEWMGR_PWM_NONE, priority_level);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *  @brief      Sets an individual led without modifying other led's within the group
 *  @details    This function may modify led's beyond the maximum group size.
 *
 *  @param      group_index : The group to set
 *  @param      selected : the index of the member within the group which will be set to intensity
 *  @param      intensity : The intensity to apply to the modified led
 *  @param      pwm_index : index of PWM to be used
 *  @param		priority_level: level of priority to be applied to the group
 */
void HblHmi__ModifyLedInGroupWithPWM(uint16 group_index, uint8 selected, uint8 intensity, uint8 pwm_index, HBLHMI_LED_PRIORITY_LEVEL_TYPE priority_level)
{
	uint8 index;
	BOOL_TYPE call_viewmgr;

	call_viewmgr = TRUE;

    #if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
	for(index = priority_level + 1; index < HBLHMI_LED_PRIORITY_MAX; index++)
	{
		if(Utilities__GetBitInArray(LedPriorityBuffer[index], LedMgr__GetLedInGroup(group_index, selected)) > 0)
		{
			call_viewmgr = FALSE;
			break;
		}
	}
    #endif

	if(call_viewmgr == TRUE)
	{
		ViewMgr__ModifyLedInGroup(group_index, selected, intensity, pwm_index);
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief Fill data buffer (usually TableLink_lliFunc) with positions of functions in regulations buffer
 * @param switchLed: Table with physical pin (or LLI_Position for touch) and read type to be linked with positions in regulations buffer
 * @param data: Table which will be filled with positions linked to physical pins
 * @param len: length of data to be filled
 * @param compartment: index of compartment
 */
void  HblHmi__InitTableLink (const uint8 *switchLed, uint8 *data, sint8 len, uint8 compartment)
{
	uint8 index_LLi;
	uint8 index_Gi;
	uint8 check_Li_Position;

	do
	{
		for (index_LLi=0; index_LLi<HBLHMI_MAX_NUM_LLI; index_LLi++)     		// Loop through all LLIs
		{
			check_Li_Position = FALSE;

			if (HblHmi_Lli_Cfg[index_LLi].LLI_ID == (*(switchLed+1)))			// LLI_ID of LLI matches the one that is searched e.g. HBL_LLI_DIGITAL for key
			{
				if (HblHmi_Lli_Cfg[index_LLi].LLI_ID == HBL_LLI_TOUCH_KEY)  	// Special management for touch keys. They do not have Pin_Ptr property
				{
					if(HblHmi_Lli_Cfg[index_LLi].LLI_Position == (*switchLed)) 	// LLI position must much for touch key.
					{
						check_Li_Position = TRUE;
					}
				}
				else if ((*switchLed) == *(HblHmi_Lli_Cfg[index_LLi].Pin_Ptr))	// For inputs with physical pin assigned check Pin_Ptr
				{   // Could be more pins that pilot the same Input (The Input must be with one pin).
					check_Li_Position = TRUE;
				}

				if (check_Li_Position == TRUE)
				{
					for (index_Gi=0; index_Gi<HBLHMI_MAX_NUM_GI; index_Gi++)	//LLI found, check GI
					{
						if ((HblHmi_Gi_Cfg[index_Gi].LLI_position == HblHmi_Lli_Cfg[index_LLi].LLI_Position) && // GI with same LLI position as desired
							(HblHmi_Gi_Cfg[index_Gi].LLI_ID == HblHmi_Lli_Cfg[index_LLi].LLI_ID))				// Additional check to be sure LLI_ID it the one desired.
																												// There can be HBL_LLI_DIGITAL with LLI position 0
																												// and HBL_LLI_TOUCH_KEY with LLI position 0
							{
								*data = Regulations__GetFunctionPositionByGi(HblHmi_Gi_Cfg[index_Gi].GI_Position, HblHmi_Gi_Cfg[index_Gi].GI_Read_Type, compartment);
								break;	// Function found. Stop looping GIs
							}
					}
					break;	// Function found. Stop looping LLIs
				}
			}
		}

		switchLed += 2; // Increase row Buffer in Input.
		data += 1; 		// Increase row Buffer Table Link.
		--len;
	}
	while (len > 0);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Set data for the virtual generic input..
 * @param   read_type: See HBLHMI_GI_READ_TYPE
 * @param   gi_position: Position of the generic input
 * @param	val_gi_virtual: value to be applied to virtual gi
 */
void HblHmi__SetVirtualGiBuffer(HBLHMI_GI_READ_TYPE read_type, uint8 gi_position, uint8 val_gi_virtual)
{
	sint16 pos_index;

    pos_index = 0x7FFF;

    switch (read_type)
    {
        case HBLHMI_GI_READ_DIGITAL:
            pos_index = gi_position - HblHmi_Num_GI.Digital;
            break;
        case HBLHMI_GI_READ_ANALOG:
            pos_index = gi_position - HblHmi_Num_GI.Analog;
            break;
        case HBLHMI_GI_READ_ENCODER:
            pos_index = gi_position - HblHmi_Num_GI.Encoder;
            break;
    }

    if (pos_index < 0)
    {
    	LOG_ADD_EXCEPTION(INCORRECT_NUMBER_OF_GI_VIRTUAL, (uint16)pos_index);
    }
    else
    {
		switch(read_type)
		{
			#if (HBL_GI_NUM_KEY > 0) || (HBL_GI_NUM_SRKEY > 0)
			case HBLHMI_GI_READ_DIGITAL:
				if (pos_index < HBLHMI_VIRTUAL_GI_DIGITAL_BUFFER_SIZE)
				{
					HblHmi_Virtual_GI_Digital_Buffer[pos_index].Current_State  = (HBL_KEY_TYPE)val_gi_virtual;
					HblHmi_Virtual_GI_Digital_Buffer[pos_index].Previous_State = (HBL_KEY_TYPE)0;
				}
				break;
			#endif

			#if (HBL_GI_NUM_ANALOG_POTENTIOMETER > 0) || (HBL_GI_NUM_DISCRETE_POTENTIOMETER > 0) || (HBL_GI_NUM_TOUCH_SLIDER > 0) || (HBL_GI_NUM_TOUCH_WHEEL > 0)
			case HBLHMI_GI_READ_ANALOG:
				if (pos_index < HBLHMI_VIRTUAL_GI_ANALOG_BUFFER_SIZE)
				{
					HblHmi_Virtual_GI_Analog_Buffer[pos_index].Current_Value  = val_gi_virtual;
					HblHmi_Virtual_GI_Analog_Buffer[pos_index].Previous_Value = val_gi_virtual-1;
				}
				break;
			#endif

			#if ((HBL_GI_NUM_INCREMENTAL_ENCODER > 0) || (HBL_GI_NUM_ABSOLUTE_ENCODER > 0))
			case HBLHMI_GI_READ_ENCODER:
				if (pos_index < HBLHMI_VIRTUAL_GI_ENCODER_BUFFER_SIZE)
				{
					HblHmi_Virtual_GI_Encoder_Buffer[pos_index].Current_Enc_Value  = val_gi_virtual;
					HblHmi_Virtual_GI_Encoder_Buffer[pos_index].Previous_Enc_Value = val_gi_virtual-1;
				}
				break;
			#endif
		}
    }
}

#if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
//---------------------------------------------------------------------------------------------------------------------
/**
 *	@brief 	Set the LedPriority Buffer
 *	@param 	priority_level: Level of priority
 *	@param  led_group: Led group index
 *  @param  led_pattern: Pattern within led group
 *  @param  value: value to be set
 *  @return	Filtered led pattern
 */
uint32 HblHmi__SetLedPriorityBuffer(HBLHMI_LED_PRIORITY_LEVEL_TYPE priority_level, uint16 led_group, uint32 led_pattern, BOOL_TYPE value)
{
    SETTINGFILE_LOADER_TYPE sf_loader;
	uint32 pattern_mask;
	uint32 ret_val;
    uint8* led_priority_buffer;
	uint8 index;

	pattern_mask = led_pattern;
	ret_val = led_pattern;
	led_priority_buffer = &LedPriorityBuffer[priority_level][0];

    //Verify that the group is in the valid range
    if ((led_group < LED_GROUP_NUM) &&
        (SettingFile__BasicLoader(SF_PTR_UI_LED_GROUP_CONFIGURATION, led_group, &sf_loader) == PASS))
    {
        for (index = 0; index < sf_loader.Length; index++)
        {
            if (sf_loader.Data[index] != INVALID_LED_INDEX)  // Cover case where an extra led index was added for word alignment only
            {
                // If the corresponding pattern bit is 1, set priority request
                if ((pattern_mask & 1) == 1)
                {
                	if(value == TRUE)
                	{
                		if(Utilities__GetBitInArray(led_priority_buffer, sf_loader.Data[index]) > 0)	// If the priority mask has already been set for this priority level
                		{
                			ret_val &= ~(uint32)((1 << index));	// Clear the bit in the led_pattern to avoid a double processing
                		}
                	}

        			Utilities__SetBitInArray(led_priority_buffer, sf_loader.Data[index], (uint8)value);	// Set the led priority bit
                }

                // Shift the next bit into place to be checked
                pattern_mask = (pattern_mask >> 1);
            }
        }
    }

    return ret_val;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *  @brief  Applies new LED states which are NOT used in animations.
 *          Should be executed every 100ms.
 */
void HblHmi__ApplyNonAnimationsBuffer(void)
{
    for(uint16 i = 0; i < NUM_OF_LEDS; i++)
    {
        // Find all leds not used for animations
        if(Utilities__GetBitInArray(LedPriorityBuffer[HBLHMI_LED_PRIORITY_LEDANIMATIONMGR], i) == 0)
        {
            ViewMgr__SetLedState(i);
        }
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *  @brief  Applies new LED states which are used in animations.
 *          Recommended to be executed every 5ms.
 */
void HblHmi__ApplyAnimationsBuffer(void)
{
    for(uint16 i = 0; i < NUM_OF_LEDS; i++)
    {
        // Find all leds used for animations
        if(Utilities__GetBitInArray(LedPriorityBuffer[HBLHMI_LED_PRIORITY_LEDANIMATIONMGR], i) > 0)
        {
            ViewMgr__SetLedState(i);
        }
    }
}
#endif

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   This method checks the integrity of the HblHmi data for GIs and LLIs
 */
void SRHblHmi__CheckDataIntegrity(void)
{
    #if (SYSTEM_ENABLE_TASKSEQUENCE == ENABLED)
        SRTaskSequence__SetSequenceStep(SRTASKSEQUENCE_APPL_SAFETY_THREAD, SRTASKSEQUENCE_APPL_SRHBLHMI_START);
    #endif

    uint8 index;

    // Check consistency of LLI configuration data
    for (index = 0; index < HBLHMI_MAX_NUM_LLI; index++)
    {
        if (HblHmi_Lli_Cfg_Crc[index] != Crc8(0xFF,(uint8 *)(void *)&HblHmi_Lli_Cfg[index],sizeof(HBL_LLI_TYPE)))
        {
            SRException__Queue(SREXCEPTION_HBL_DATA_NOT_CONSISTENT,0x1E,0xE1);
        }

        if(SR_CHECK_BYTE(HblHmi_LLI_Sequence_Num[index]) != SRDATA_OK)
        {
            SRException__Queue(SREXCEPTION_HBL_DATA_NOT_CONSISTENT,0x2E,0xE2);
        }
    }

    // Check consistency of GI configuration data
    for (index = 0; index < HBLHMI_MAX_NUM_GI; index++)
    {
        if (HblHmi_Gi_Cfg_Crc[index] != Crc8(0xFF,(uint8 *)(void *)&HblHmi_Gi_Cfg[index],sizeof(HBLHMI_GI_TYPE)))
        {
            SRException__Queue(SREXCEPTION_HBL_DATA_NOT_CONSISTENT,0x1F,0xF1);
        }
    }

    // Check consistency of variable that tracks the number of LLIs in the setting file
    if (SR_CHECK_BYTE(HblHmi_Num_Lli) != SRDATA_OK)
    {
        SRException__Queue(SREXCEPTION_HBL_DATA_NOT_CONSISTENT,0x1D,0xD1);
    }

    // Check consistency of variable that tracks the number of GIs in the setting file
    if (SR_CHECK_BYTE(HblHmi_Num_Total_GI) != SRDATA_OK)
    {
        SRException__Queue(SREXCEPTION_HBL_DATA_NOT_CONSISTENT,0x2D,0xD2);
    }

    // Execute all background functions that validate protected variables for the LLI modules
    HBLHMI_PROCESS_SRLLI_HANDLERS();
}
//=====================================================================================================================
//-------------------------------------- Private Functions ------------------------------------------------------------
//=====================================================================================================================

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Returns a pointer to the buffer of data for the virtual generic input per the read type and position.
 * @param   read_type: See HBLHMI_GI_READ_TYPE
 * @param   gi_position: Position of the generic input
 */
static void * GetVirtualGiBufferPtr(HBLHMI_GI_READ_TYPE read_type, uint8 gi_position)
{
    void * retval;
    sint16 pos_index;

    pos_index = 0x7FFF;
    retval = NULL;

    switch (read_type)
    {
        case HBLHMI_GI_READ_DIGITAL:
            pos_index = gi_position - HblHmi_Num_GI.Digital;
            break;
        case HBLHMI_GI_READ_ANALOG:
            pos_index = gi_position - HblHmi_Num_GI.Analog;
            break;
        case HBLHMI_GI_READ_ENCODER:
            pos_index = gi_position - HblHmi_Num_GI.Encoder;
            break;
    }

    if (pos_index < 0)
    {
    	LOG_ADD_EXCEPTION(INCORRECT_NUMBER_OF_GI_VIRTUAL, (uint16)pos_index);
    }
    else
    {
		switch(read_type)
		{
			#if (HBL_GI_NUM_KEY > 0) || (HBL_GI_NUM_SRKEY > 0)
			case HBLHMI_GI_READ_DIGITAL:
				if (pos_index < HBLHMI_VIRTUAL_GI_DIGITAL_BUFFER_SIZE)
				{
					retval = &HblHmi_Virtual_GI_Digital_Buffer[gi_position - HblHmi_Num_GI.Digital];
				}
				break;
			#endif

			#if (HBL_GI_NUM_ANALOG_POTENTIOMETER > 0) || (HBL_GI_NUM_DISCRETE_POTENTIOMETER > 0) || (HBL_GI_NUM_TOUCH_SLIDER > 0) || (HBL_GI_NUM_TOUCH_WHEEL > 0)
			case HBLHMI_GI_READ_ANALOG:
				if (pos_index < HBLHMI_VIRTUAL_GI_ANALOG_BUFFER_SIZE)
				{
					retval = &HblHmi_Virtual_GI_Analog_Buffer[gi_position - HblHmi_Num_GI.Analog];
				}
				break;
			#endif

			#if ((HBL_GI_NUM_INCREMENTAL_ENCODER > 0) || (HBL_GI_NUM_ABSOLUTE_ENCODER > 0))
			case HBLHMI_GI_READ_ENCODER:
				if (pos_index < HBLHMI_VIRTUAL_GI_ENCODER_BUFFER_SIZE)
				{
					retval = &HblHmi_Virtual_GI_Encoder_Buffer[gi_position - HblHmi_Num_GI.Encoder];
				}
				break;
			#endif

			default:
				break;
		}
    }

    return (retval);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Returns an index to a table that contains all of the functions for a given GI type
 * @param   generic_input: See HBLHMI_GI_ENUM_TYPE
 * @return  Index to a table that contains all of the functions for a given GI type
 */
static uint8 GetGiHandler(HBLHMI_GI_ENUM_TYPE generic_input)
{
    uint8 index;
    uint8 retval;

    retval = 0xFF;

    for (index = 0; index < HBLHMI_NUM_GI_HANDLERS; index++)
    {
        if (HBLHMI_GI_HANDLERS[index].GI_ID == generic_input)
        {
            retval = index;
            break;
        }
    }
    return (retval);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief
 * @param input
 * @return
 */
static uint8 GetLliHandler(HBL_LLI_ENUM_TYPE input)
{
    uint8 index;
    uint8 retval;

    retval = 0xFF;

    for (index = 0; index < HBLHMI_NUM_LLI_HANDLERS; index++)
    {
        if (HBLHMI_LLI_HANDLERS[index].LLI_ID == input)
        {
            retval = index;
            break;
        }
    }
    return (retval);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *
 * @param gi_event: See HBLHMI_GI_EVENT_TYPE
 */
static void GIEventHandler(HBLHMI_GI_EVENT_TYPE gi_event)
{
    CALLBACK_EVENT_TYPE event;
    event = gi_event.GI_Position;
    event = event | ((gi_event.GI_Read_Type) << 6);
    Callback__Notify(&HblHmi_GI_Callback_Control_Structure, event);
    Callback__Notify(&HblHmi_Sequence_Callback_Control_Structure, event);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *  Initialization of the generic inputs
 */
static void GiInitialize(void)
{
    uint8 index;
    uint16 * data_ptr;
    SETTINGFILE_LOADER_TYPE gi_table;
    SETTINGFILE_LOADER_TYPE gi_pin_table;
    uint8 num_of_gi;

    SR_FILL(HblHmi_GI_Sequence_Num, 0x00, sizeof(HblHmi_GI_Sequence_Num));
    memset(&HblHmi_Num_GI, 0, sizeof(HblHmi_Num_GI));

    for (index=0; index < HBLHMI_NUM_GI_HANDLERS; index++)
    {
        if (HBLHMI_GI_HANDLERS[index].Initialize != NULL)
        {
            HBLHMI_GI_HANDLERS[index].Initialize();
        }
    }

    SettingFile__BasicLoader(SF_PTR_UI_IO_CONFIG, SF_DISPL_GENERIC_INPUT_MAP, &gi_table);
    SettingFile__BasicLoader(SF_PTR_UI_IO_CONFIG, SF_DISPL_MODULE_PIN_MAP, &gi_pin_table);

    num_of_gi = gi_table.Length / NUM_BYTES_GI_MAP;

    for (index = 0; index < HBLHMI_MAX_NUM_GI; index++)
    {
        HblHmi_Gi_Cfg[index].LLI_ID = HBL_LLI_INVALID;

        if (index < num_of_gi)
        {
            // Get a word of data
            data_ptr = (uint16 *)&gi_table.Data[NUM_BYTES_GI_MAP * index];       //lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

            HblHmi_Gi_Cfg[index].LLI_ID = (HBL_LLI_ENUM_TYPE)(LOBYTE(*data_ptr));
            HblHmi_Gi_Cfg[index].GI_ID = (HBLHMI_GI_ENUM_TYPE)(HIBYTE(*data_ptr));

            // Get the next word of data
            data_ptr++;

            // Setup the pointer to the device parameters for the GI (if they exist)
            if (LOBYTE(*data_ptr) != NO_PARAMETER_OFFSET)
            {
                SettingFile__BasicLoader(SF_PTR_UI_IO_DEVICE, LOBYTE(*data_ptr), &HblHmi_Gi_Cfg[index].Parameter_Ptr);
            }
            else
            {
                HblHmi_Gi_Cfg[index].Parameter_Ptr.Data = NULL;
                HblHmi_Gi_Cfg[index].Parameter_Ptr.Length = 0;
            }
            HblHmi_Gi_Cfg[index].LLI_position = HIBYTE(*data_ptr) & 0x7F;

            // Get the next word of data
            data_ptr++;

            HblHmi_Gi_Cfg[index].GI_Read_Type = (HBLHMI_GI_READ_TYPE)(LOBYTE(*data_ptr));
            HblHmi_Gi_Cfg[index].GI_Position = HIBYTE(*data_ptr) & 0x7F;

            switch (HblHmi_Gi_Cfg[index].GI_Read_Type)
            {
                case HBLHMI_GI_READ_DIGITAL:
                    HblHmi_Num_GI.Digital++;
                    break;
                case HBLHMI_GI_READ_ANALOG:
                    HblHmi_Num_GI.Analog++;
                    break;
                case HBLHMI_GI_READ_ENCODER:
                    HblHmi_Num_GI.Encoder++;
                    break;
            }

            HblHmi_Gi_Cfg[index].GI_Handler_Index = GetGiHandler(HblHmi_Gi_Cfg[index].GI_ID);

            if (HblHmi_Gi_Cfg[index].GI_Handler_Index == 0xFF)
            {
                LOG_ADD_EXCEPTION(UNSUPPORTED_GI_TYPE, HblHmi_Gi_Cfg[index].GI_ID);
            }

            HblHmi_Gi_Cfg[index].LLI_Config_Index = HblHmi__GetLLIIndexByID(HblHmi_Gi_Cfg[index].LLI_ID, HblHmi_Gi_Cfg[index].LLI_position);

            if (HblHmi_Gi_Cfg[index].GI_Handler_Index < HBLHMI_NUM_GI_HANDLERS)
            {
                if (HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].Allocate != NULL)
                {
                    HblHmi_Gi_Cfg[index].Data_Index = HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].Allocate();

                }

                if (HblHmi_Gi_Cfg[index].Data_Index < 0xFF)
                {
                    HblHmi_Gi_Cfg[index].Parameter_Size = HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].Parameter_Size;

                    if (HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].InitializeInstance != NULL)
                    {
                        HBLHMI_GI_HANDLERS[HblHmi_Gi_Cfg[index].GI_Handler_Index].InitializeInstance(&HblHmi_Gi_Cfg[index], HblHmi_LLI_Sequence_Num [HblHmi_Gi_Cfg[index].LLI_Config_Index]);
                    }
                }
            }
        }
        HblHmi_Gi_Cfg_Crc[index] = Crc8(0xFF,(uint8 *)(void *)&HblHmi_Gi_Cfg[index],sizeof(HBLHMI_GI_TYPE));
    }
    SR_SET_BYTE(HblHmi_Num_Total_GI, num_of_gi);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Initialization of the low level inputs
 */
static void LliInitialize(void)
{
    uint8 index;
    uint8 * ptr;
    SETTINGFILE_LOADER_TYPE lli_table;
    SETTINGFILE_LOADER_TYPE lli_pin_table;
    uint8 num_of_lli;

    SR_FILL(HblHmi_LLI_Sequence_Num, 0x00, sizeof(HblHmi_LLI_Sequence_Num));

    SettingFile__BasicLoader(SF_PTR_UI_IO_CONFIG, SF_DISPL_LOW_LEVEL_INPUT_MAP, &lli_table);
    SettingFile__BasicLoader(SF_PTR_UI_IO_CONFIG, SF_DISPL_MODULE_PIN_MAP, &lli_pin_table);

    num_of_lli = lli_table.Length / NUM_BYTES_LLI_MAP;

    #if (HBLHMI_LLI_INITIALIZATION_FEATURE == ENABLED)
        for (index=0; index < HBLHMI_NUM_LLI_HANDLERS; index++)
        {
            if (HBLHMI_LLI_HANDLERS[index].Initialize != NULL)
            {
                HBLHMI_LLI_HANDLERS[index].Initialize();
            }
        }
    #endif

    for (index = 0; index < HBLHMI_MAX_NUM_LLI; index++)
    {
        HblHmi_Lli_Cfg[index].LLI_ID = HBL_LLI_INVALID;
        HblHmi_Lli_Cfg[index].Data_Index = 0xFF;

        if (index < num_of_lli)
        {
            ptr = &lli_table.Data[NUM_BYTES_LLI_MAP * index];

            HblHmi_Lli_Cfg[index].LLI_ID = (HBL_LLI_ENUM_TYPE)(ptr[0]);
            HblHmi_Lli_Cfg[index].Pin_Ptr = &lli_pin_table.Data[ptr[1]];

            if (ptr[2] != NO_PARAMETER_OFFSET)
            {
                SettingFile__BasicLoader(SF_PTR_UI_IO_DEVICE, ptr[2], &HblHmi_Lli_Cfg[index].Parameter_Ptr);
            }
            else
            {
                HblHmi_Lli_Cfg[index].Parameter_Ptr.Data = NULL;
                HblHmi_Lli_Cfg[index].Parameter_Ptr.Length = 0;
            }

            HblHmi_Lli_Cfg[index].LLI_Mux = (BIT7_MASK & ptr[3]) >> 7; // Extract the Mux bit
            HblHmi_Lli_Cfg[index].LLI_Position = (0x7F & ptr[3]);

            HblHmi_Lli_Cfg[index].LLI_Handler_Index = GetLliHandler(HblHmi_Lli_Cfg[index].LLI_ID);

            if (HblHmi_Lli_Cfg[index].LLI_Handler_Index < HBLHMI_NUM_LLI_HANDLERS)
            {
                if (HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].Allocate != NULL)
                {
                    HblHmi_Lli_Cfg[index].Data_Index =  HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].Allocate();
                }

                if (HblHmi_Lli_Cfg[index].Data_Index < HBL_INDEX_INVALID)
                {
                    if (HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].InitializeInstance != NULL)
                    {
                        HBLHMI_LLI_HANDLERS[HblHmi_Lli_Cfg[index].LLI_Handler_Index].InitializeInstance(&HblHmi_Lli_Cfg[index]);
                    }

                }
            }
        }
        HblHmi_Lli_Cfg_Crc[index] = Crc8(0xFF,(uint8 *)(void *)&HblHmi_Lli_Cfg[index],sizeof(HBL_LLI_TYPE));
    }
    SR_SET_BYTE(HblHmi_Num_Lli, num_of_lli);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Increase the LLI Sequence counter. After a buffer overflow, the counter is set to 1, so it's possible to catch a reset
 * @param   index: Index of the HblHmi_LLI array
 */
static void UpdateLLISequence(uint8 index)
{
	if(SR_CHECK_BYTE(HblHmi_LLI_Sequence_Num[index]) != SRDATA_OK)
	{
		SRException__Queue(SREXCEPTION_HBL_DATA_NOT_CONSISTENT,0x2E,0xE2);
	}

	SR_SET_BYTE(HblHmi_LLI_Sequence_Num[index], HblHmi_LLI_Sequence_Num[index] + 1);

    if (HblHmi_LLI_Sequence_Num[index] == 0)
    {
    	SR_SET_BYTE(HblHmi_LLI_Sequence_Num[index], 1);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Increase the GI Sequence counter. After a buffer overflow, the counter is set to 1, so it's possible to catch a reset
 * @param   index: Index of the HblHmi_GI array
 */
static void UpdateGISequence(uint8 index)
{
	if(SR_CHECK_BYTE(HblHmi_GI_Sequence_Num[index]) != SRDATA_OK)
	{
		SRException__Queue(SREXCEPTION_HBL_DATA_NOT_CONSISTENT,0x2F,0xF2);
	}

	SR_SET_BYTE(HblHmi_GI_Sequence_Num[index], HblHmi_GI_Sequence_Num[index] + 1);

    if (HblHmi_GI_Sequence_Num[index] == 0)
    {
    	SR_SET_BYTE(HblHmi_GI_Sequence_Num[index], 1);
    }
}
