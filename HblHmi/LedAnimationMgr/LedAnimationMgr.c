/**
 *  @file
 *
 *  @brief
 *
 *  @details
 *
    @startuml{LedAnimationMgr_Class_Diagram.png}
    title LedAnimationMgr Class Diagram

    hide empty attributes
    hide empty methods
    hide circle
    skinparam classAttributeIconSize 0

    class "LedAnimationMgr" as core {
      +LedAnimationMgr__Initialize() : void
      +LedAnimationMgr__Handler() : void
      +LedAnimationMgr__Start(LED_ANIMATIONS_ENUM_TYPE animation_index, uint16 led_group, uint32 led_pattern, uint8 num_of_repeats) : void
      +LedAnimationMgr__Pause(uint16 led_group, uint32 led_pattern, uint16 pause_time) : void
      +LedAnimationMgr__Resume(uint16 led_group, uint32 led_pattern) : void
      +LedAnimationMgr__Stop(uint16 led_group, uint32 led_pattern) : void
      +LedAnimationMgr__StopAll() : void
      +LedAnimationMgr__RegisterEventHandler(LEDANIMATIONMGR_EVENT_HANDLER_TYPE event_handler) : void
      +LedAnimationMgr__UnregisterEventHandler(LEDANIMATIONMGR_EVENT_HANDLER_TYPE event_handler) : void
	  +LedAnimationMgr__GetAnimationStorePtr(uint8 index) : LED_ANIMATIONS_TYPE* BOOL_TYPE
	  +LedAnimationMgr__IsAnimationRunning(uint8 led_group, uint8* out_anim_index) : BOOL_TYPE
    }

    class "LedAnimationMgr Dynamic" as dynamic <<interface>>{
    #MACRO_1
	+MACRO_2
    }

    core ..|> dynamic

    @enduml

    @startuml{LedAnimationMgr_State_Machine.png}
    title LedAnimationMgr State-Machine

        [*] --> STATE_ONE

		STATE_ONE : enter / StateOneEnter()
        STATE_ONE : do / StateOneDo()
		STATE_ONE : exit / StateOneExit()
        STATE_ONE --> STATE_TWO : evTransitionEventOne \ / TransitionActionOne()

        STATE_TWO --> [*] : evTransitionEventTwo \n / TransitionActionTwo()

    @enduml


    @startuml{LedAnimationMgr_Sequence.png}
        title LedAnimationMgr Sequence Diagram

        participant "SetAnimation or \nEmbedded call" as Source
        participant LedAnimationMgr
    	participant HblHmi
        participant LedMgr

        loop For each allocated animation
			alt Animation running
				alt Remaining animation repeats > 0
					alt Remaining pattern executions > 0
						alt Remaining pattern steps > 0
							LedAnimationMgr -> LedAnimationMgr: Load next pattern step
							LedAnimationMgr -> HblHmi: Request LEDs state change
							HblHmi -> HblHmi: Evaluate LEDs state \nrequests priority
							HblHmi -> LedMgr: Set LEDs state
						else
							LedAnimationMgr -> LedAnimationMgr: Load next pattern execution
						end
					else
						LedAnimationMgr -> LedAnimationMgr: Load next animation repeat
					end
				else
					LedAnimationMgr -> LedAnimationMgr: Stop and deallocate animation
				end
			else Animation paused
				rnote over LedAnimationMgr
					Handle pause countdown
				endrnote
			end
		end

		Source -> LedAnimationMgr : StartAnimation
        rnote over LedAnimationMgr
			- Read animation info from SF
			- Store animation config in RAM
			- Start Animation
		endrnote

		Source -> LedAnimationMgr : StopAnimation
        rnote over LedAnimationMgr
			- Stop Animation
			- Free memory allocation
		endrnote

		Source -> LedAnimationMgr : PauseAnimation
        rnote over LedAnimationMgr
			- Pause Animation
			- Set pause countdown timer
		endrnote

		Source -> LedAnimationMgr : ResumeAnimation
        rnote over LedAnimationMgr
			- Resume Animation
			- Reload animation timers
		endrnote

		Source -> LedAnimationMgr : SetGroupPercentage
		rnote over LedAnimationMgr
			- Calculate led pattern
		endrnote
		LedAnimationMgr -> HblHmi: Request LEDs state change
		HblHmi -> HblHmi: Evaluate LEDs state \nrequests priority
		HblHmi -> LedMgr: Set LEDs state
    @enduml
 *
 *  $Header: LedAnimationMgr.c 1.0 2016/04/15 04:55:18EDT Marco Di Goro (DIGORM) Exp  $
 *
 *  @copyright  Copyright 20165-$Date: 2016/04/15 04:55:18EDT $. Whirlpool Corporation. All rights reserved - CONFIDENTIAL
 */
//---------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------

//-------------------------------------- Include Files ----------------------------------------------------------------
#include "SystemConfig.h"
#include "LedAnimationMgr.h"
#include "LedAnimationMgr_prv.h"
#include "Callback.h"
#include "HblHmi.h"
#include "Log.h"
#include "SettingFile.h"
#include <string.h>
#include <math.h>

//-------------------------------------- PRIVATE (Variables, Constants & Defines) -------------------------------------

//! The name of this module for use by the Log module.
#define MODULE_NAME MODULE_LEDANIMATIONMGR

//! A list of log message IDs that are generated by this module.
typedef enum MODULE_LEDANIMATIONMGR_LOG_MESSAGE_ID_ENUM
{
    ANIMATION_INSTANCE_NOT_AVAILABLE = 1
} MODULE_LEDANIMATIONMGR_LOG_MESSAGE_ID_TYPE;


#ifndef MAX_ACTIVE_ANIMATIONS
	#define MAX_ACTIVE_ANIMATIONS 1
#endif

#ifndef SEQUENCE_TAIL_INTENSITY_STEPS_SCALING
	#define SEQUENCE_TAIL_INTENSITY_STEPS_SCALING 0
#endif

#ifndef LED_ANIMATION_SYNC_BLINK
    #define LED_ANIMATION_SYNC_BLINK DISABLED
#endif

#ifndef LEDANIMATIONMGR_HANDLER_5MS
    //Recommendation to ENABLE this and run from 5ms thread
    #define LEDANIMATIONMGR_HANDLER_5MS DISABLED
#endif

static LED_ANIMATIONS_TYPE Animation_Store_Mgr[MAX_ACTIVE_ANIMATIONS];
static uint8 Current_Pwm_Index;

//! Define the callback control structure module static variable
DEFINE_CALLBACK_CONTROL_STRUCTURE(LedAnimationMgr_Callback_Control_Structure, LEDANIMATIONMGR_CALLBACK_REGISTERS_SIZE);

#define GET_HIGH_PARAMETER(data) 	((data & 0xE0) >> 5)
#define GET_LOW_PARAMETER(data) 	(data & 0x1F)

#define LED_PWM_TABLE_SIZE 10

//-------------------------------------- PRIVATE (Function Prototypes) ------------------------------------------------
static LED_ANIMATIONS_TYPE * GetNextAvailableAnimationInstance(void);
static void InitAnimation(LED_ANIMATIONS_TYPE * animation_instance, uint32 led_pattern, uint8 * sf_data);
static void LoadAnimationNextStep(LED_ANIMATIONS_TYPE * animation_instance);
static void StartAnimation(LED_ANIMATIONS_TYPE * animation_ptr);
static void StopAnimation(LED_ANIMATIONS_TYPE * animation_ptr);
static void RunAnimation(LED_ANIMATIONS_TYPE * animation_ptr);

static void HandleFadingAnimation(LED_ANIMATIONS_TYPE * animation_ptr);
static void HandleBlinkAnimation(LED_ANIMATIONS_TYPE * animation_ptr);
static void HandleSequenceAnimation(LED_ANIMATIONS_TYPE * animation_ptr);
static uint8 FindAnimationIndex(uint8 led_group, uint32 led_pattern);
static uint8 FindNextSequenceHeadLed(LED_ANIMATIONS_TYPE * animation_ptr);
#if LED_ANIMATION_SYNC_BLINK == ENABLED
static void SyncBlinkAnimation(LED_ANIMATIONS_TYPE * animation_ptr);
#endif

static void ExecuteCallBack(LED_ANIMATIONS_TYPE * animation_ptr);
//=====================================================================================================================
//-------------------------------------- Public Functions -------------------------------------------------------------
//=====================================================================================================================

//---------------------------------------------------------------------------------------------------------------------
/**
 *  @brief	Initializes the module LedAnimationMgr and its variables
 */
void LedAnimationMgr__Initialize(void)
{
    memset(Animation_Store_Mgr, 0, sizeof(Animation_Store_Mgr));
    Current_Pwm_Index = 0;
    Callback__Initialize(&LedAnimationMgr_Callback_Control_Structure);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Animation engine handler
 *    @details  Recommended call rate is 5ms from Asynchronous thread.
 *              Calling from interruption (1ms) may cause overflow on all running threads.
 */
void LedAnimationMgr__Handler(void)
{
    uint8 index;

    for (index = 0; index < MAX_ACTIVE_ANIMATIONS; index++)
    {
        RunAnimation(&Animation_Store_Mgr[index]);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Start the selected animation with the given parameters
 *    @param 	animation_index : animation displacement
 *    @param 	led_group
 *    @param 	led_pattern
 *    @param	num_of_repeats : number of animation repeats
 */
void LedAnimationMgr__Start(LED_ANIMATIONS_ENUM_TYPE animation_index, uint16 led_group, uint32 led_pattern, uint8 num_of_repeats)
{
	SETTINGFILE_LOADER_TYPE sf_loader;
	LED_ANIMATIONS_TYPE * animation_instance;
	uint16* data_ptr;
	uint8 index;

	if(led_pattern != LED_PATTERN_ANY) // Avoid starting the animation with the pattern = 0. No reason to start such animation.
	{
		if (SettingFile__BasicLoader(SF_PTR_UI_LED_ANIMATION, animation_index, &sf_loader) == PASS)
		{
			data_ptr = (uint16 *)sf_loader.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			for(index = 0; index < MAX_ACTIVE_ANIMATIONS; index++)
			{
				if(Animation_Store_Mgr[index].Led_Group == led_group &&
						Animation_Store_Mgr[index].Animation_Status != LED_ANIMATION_IDLE)	// No need to stop an animation in IDLE state
				{
					LedAnimationMgr__Stop(led_group, led_pattern);
					break;
				}
			}

			animation_instance = GetNextAvailableAnimationInstance();
			if (animation_instance != NULL)
			{
				//toggle the pwm index so the next animation uses a different pwm index buffer from the previous called animation
				//the pwm buffer is only used if the animation calls the Led9532 driver
				Current_Pwm_Index ^= 1;
				animation_instance->Pwm_Index = Current_Pwm_Index;

				animation_instance->Led_Group = led_group;
				animation_instance->Repeat_Num = num_of_repeats;
				animation_instance->Led_Pattern = led_pattern;

				animation_instance->Animation_Index = animation_index;
				animation_instance->Animation_Type = (LED_ANIMATION_TYPE)GET_HIGH_PARAMETER(sf_loader.Data[0]);
				animation_instance->Pattern_Executions = GET_LOW_PARAMETER(sf_loader.Data[0]);
#if (LEDANIMATIONMGR_HANDLER_5MS == ENABLED)
				//When running on 5ms divide the parameters to fit the handler call rate
				animation_instance->Animation_Period = (data_ptr[1])/5;
#else
				animation_instance->Animation_Period = data_ptr[1];
#endif
				animation_instance->Is_Reversing = FALSE;
				memcpy(&animation_instance->Flags, &sf_loader.Data[1], sizeof(animation_instance->Flags));
				InitAnimation(animation_instance, led_pattern, sf_loader.Data);

#if LED_ANIMATION_SYNC_BLINK == ENABLED
				SyncBlinkAnimation(animation_instance);
#endif

				StartAnimation(animation_instance);
			}
			else
			{
				LOG_ADD_EXCEPTION(ANIMATION_INSTANCE_NOT_AVAILABLE, 0);
			}
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Pause the selected animation for the given time
 *    @param 	led_group
 *    @param 	led_pattern
 *    @param	pause_time
 */
void LedAnimationMgr__Pause(uint16 led_group, uint32 led_pattern, uint16 pause_time)
{
    uint8 index;

    index = FindAnimationIndex(led_group, led_pattern);

    if(index != INVALID_VALUE)
    {
    	Animation_Store_Mgr[index].Time_Between_Cycles = pause_time;	// Set Pause timer
    	Animation_Store_Mgr[index].Animation_Status = LED_ANIMATION_PAUSED;

		Animation_Store_Mgr[index].Event_Mask.Pause = TRUE;
		ExecuteCallBack(&Animation_Store_Mgr[index]);
		Animation_Store_Mgr[index].Event_Mask.Pause = FALSE;
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Resume the selected animation
 *    @param 	led_group
 *    @param 	led_pattern
 */
void LedAnimationMgr__Resume(uint16 led_group, uint32 led_pattern)
{
	SETTINGFILE_LOADER_TYPE sf_loader;
    uint8 index;

    index = FindAnimationIndex(led_group, led_pattern);

    if(index != INVALID_VALUE)
    {
    	if(Animation_Store_Mgr[index].Animation_Status == LED_ANIMATION_PAUSED)
		{
			if (SettingFile__BasicLoader(SF_PTR_UI_LED_ANIMATION, Animation_Store_Mgr[index].Animation_Index, &sf_loader) == PASS)
			{
				LoadAnimationNextStep(&Animation_Store_Mgr[index]);
				#if LED_ANIMATION_SYNC_BLINK == ENABLED
				SyncBlinkAnimation(&Animation_Store_Mgr[index]);
				#endif
				Animation_Store_Mgr[index].Animation_Status = LED_ANIMATION_RUNNING;
			}


			Animation_Store_Mgr[index].Event_Mask.Resume = TRUE;
			ExecuteCallBack(&Animation_Store_Mgr[index]);
			Animation_Store_Mgr[index].Event_Mask.Resume = FALSE;
		}
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Stop the selected animation
 *    @param 	led_group
 *    @param 	led_pattern
 */
void LedAnimationMgr__Stop(uint16 led_group, uint32 led_pattern)
{
    uint8 index;

    index = FindAnimationIndex(led_group, led_pattern);

    if(index != INVALID_VALUE)
    {
    	StopAnimation(&Animation_Store_Mgr[index]);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Stop all animations
 */
void LedAnimationMgr__StopAll(void)
{
    uint8 index;

    for(index = 0; index < MAX_ACTIVE_ANIMATIONS; index++)
    {
        StopAnimation(&Animation_Store_Mgr[index]);
    }
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Registers event handler with the module.
 * @param   event_handler: pointer to the function that handles the event
 */
void LedAnimationMgr__RegisterEventHandler(LEDANIMATIONMGR_EVENT_HANDLER_TYPE event_handler)
{
    Callback__Register(&LedAnimationMgr_Callback_Control_Structure, (CALLBACK_HANDLER_TYPE)event_handler);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Unregisters event handler with the module.
 * @param   event_handler: pointer to the function that handles the event
 */
void LedAnimationMgr__UnregisterEventHandler(LEDANIMATIONMGR_EVENT_HANDLER_TYPE event_handler)
{
    Callback__Unregister(&LedAnimationMgr_Callback_Control_Structure, (CALLBACK_HANDLER_TYPE)event_handler);	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
}

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Returns the pointer to the Animation Store
 * @param	index: Index of the animation inside the store array
 * @return  Pointer to Animation_Store_Mgr
 */
LED_ANIMATIONS_TYPE* LedAnimationMgr__GetAnimationStorePtr(uint8 index)
{
	if(index < MAX_ACTIVE_ANIMATIONS)
	{
		return (&Animation_Store_Mgr[index]);
	}
	else
	{
		return NULL;
	}
}


//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief Checks if there is any animation running on specified group.
 * @param led_group to be checked if there is any animation running on it
 * @param out_anim_index out parameter to store animation index if running.
 * 		  Can be used to get all information about animation using LedAnimationMgr__GetAnimationStorePtr
 * @return
 * @retval TRUE - there is animation running on specified group,
 * @retval FALSE - there is no animation running on specified group.
 */
BOOL_TYPE LedAnimationMgr__IsAnimationRunning(uint8 led_group, uint8* out_anim_index)
{
	BOOL_TYPE anim_running;
	uint8 index;
	LED_ANIMATIONS_TYPE* anim;

	anim_running = FALSE;

    for(index = 0; index < MAX_ACTIVE_ANIMATIONS; index++)			// Search in all animations
    {
    	anim = LedAnimationMgr__GetAnimationStorePtr(index);		// Get pointer to the animation

        if ((anim->Led_Group == led_group) &&						// Check if group is the one which specified
            (anim->Animation_Status != LED_ANIMATION_IDLE))			// Check if status of the animation is different that idle.
        {
        	anim_running = TRUE;
        	*out_anim_index = index;								// Assign found index to the out parameter
        	break;													// Once animation found break loop
        }
    }

    return anim_running;
}
//=====================================================================================================================
//-------------------------------------- Private Functions ------------------------------------------------------------
//=====================================================================================================================

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Get an available animation instance
 *    @return 	available_instance : pointer to the first animation instance (or NULL)
 */
static LED_ANIMATIONS_TYPE * GetNextAvailableAnimationInstance(void)
{
    uint8 index;
    LED_ANIMATIONS_TYPE * available_instance;
    available_instance = NULL;

    for(index = 0; index < MAX_ACTIVE_ANIMATIONS; index++)
    {
    	if(Animation_Store_Mgr[index].Animation_Status == LED_ANIMATION_IDLE)
    	{
    		available_instance = &Animation_Store_Mgr[index];
    		break;
    	}
    }

    return(available_instance);
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Run animation
 *    @details 	This method handles the pointed animation
 *    @param 	*animation_ptr : Pointer to the animation structure
 */
static void RunAnimation(LED_ANIMATIONS_TYPE * animation_ptr)
{
	SETTINGFILE_LOADER_TYPE sf_loader;
    uint16 * data_ptr;

	if(animation_ptr->Animation_Status != LED_ANIMATION_IDLE)
	{
		switch(animation_ptr->Animation_Status)
		{
			case LED_ANIMATION_RUNNING:
				if(animation_ptr->Step_Timer > 0)
				{
					animation_ptr->Step_Timer--;	//Downcounting timer
				}
				else
				{
					switch(animation_ptr->Animation_Type)
					{
						case LED_ANIMATION_FADING:
							HandleFadingAnimation(animation_ptr);
							break;
						case LED_ANIMATION_BLINK:
							HandleBlinkAnimation(animation_ptr);
							break;
						case LED_ANIMATION_SEQUENCE:
							HandleSequenceAnimation(animation_ptr);
							break;
						default:
							break;
					}

					animation_ptr->Event_Mask.Step = TRUE;
					ExecuteCallBack(animation_ptr);
					animation_ptr->Event_Mask.Step = FALSE;
				}

				break;
			case LED_ANIMATION_EXEC_OVER:
				if (SettingFile__BasicLoader(SF_PTR_UI_LED_ANIMATION, animation_ptr->Animation_Index, &sf_loader) == PASS)
				{
					if(animation_ptr->Pattern_Executions > 0)
					{
						animation_ptr->Pattern_Executions--;
						LoadAnimationNextStep(animation_ptr);	//Load first step of the next execution
						animation_ptr->Animation_Status = LED_ANIMATION_RUNNING;

						animation_ptr->Event_Mask.Exec_Over = TRUE;
						ExecuteCallBack(animation_ptr);
						animation_ptr->Event_Mask.Exec_Over = FALSE;
					}
					else if (animation_ptr->Repeat_Num > 0)	// Reload the next repeat
					{
						// Grab data loaded from Setting File
						data_ptr = (uint16 *)sf_loader.Data;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

						if(animation_ptr->Repeat_Num != LED_ANIMATIONS_PERIODIC)
						{
							animation_ptr->Repeat_Num--;
						}

						animation_ptr->Pattern_Executions = GET_LOW_PARAMETER(sf_loader.Data[0]);

						animation_ptr->Time_Between_Cycles = data_ptr[2];
						LoadAnimationNextStep(animation_ptr);

						if(animation_ptr->Time_Between_Cycles > 0)
						{
							animation_ptr->Animation_Status = LED_ANIMATION_WAITING;
						}
						else
						{
						    animation_ptr->Animation_Status = LED_ANIMATION_RUNNING;
						}

						animation_ptr->Event_Mask.Repeat_Over = TRUE;
						ExecuteCallBack(animation_ptr);
						animation_ptr->Event_Mask.Repeat_Over = FALSE;
					}
					else if (animation_ptr->Repeat_Num == 0)	//There are no more repeats, stop the animation and send animation finished event
					{
						animation_ptr->Event_Mask.Expired = TRUE;
						ExecuteCallBack(animation_ptr);
						animation_ptr->Event_Mask.Expired = FALSE;

						StopAnimation(animation_ptr);
					}
				}
				break;
			case LED_ANIMATION_PAUSED:
			case LED_ANIMATION_WAITING:
				if(animation_ptr->Time_Between_Cycles != UNLIMITED_DURATION) // Unlimited delay should not expire (pause)
				{
					animation_ptr->Time_Between_Cycles--;
					if (animation_ptr->Time_Between_Cycles == 0)
					{
	                    animation_ptr->Animation_Status = LED_ANIMATION_RUNNING;
					}
				}
				break;
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Initialize animation
 *    @details 	This method initializes the pointed animation
 *    @param 	*animation_ptr : Pointer to the animation structure
 *    @param 	led_pattern : pattern of the led which will perform the pointed animation
 *    @param 	*sf_data : pointer to read setting file data
 */
static void InitAnimation(LED_ANIMATIONS_TYPE * animation_ptr, uint32 led_pattern, uint8 * sf_data)
{
	FADING_PARAMETER_TYPE *fading_data;
	BLINK_PARAMETER_TYPE *blink_data;
	SEQUENCE_PARAMETER_TYPE* sequence_data;

	animation_ptr->Led_Pattern = led_pattern;

	switch(animation_ptr->Animation_Type)
	{
		case LED_ANIMATION_FADING:
			// Load Fading specific animation data
			fading_data = (FADING_PARAMETER_TYPE *)animation_ptr->Parameters;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

			// Select initial or final intensity, depending on the animation direction
			fading_data->Initial_Intensity = sf_data[6];
			fading_data->Final_Intensity = sf_data[7];
			if(animation_ptr->Flags.Direction == TRUE)
			{
                fading_data->Current_Intensity = fading_data->Final_Intensity;
			}
			else
			{
			    fading_data->Current_Intensity = fading_data->Initial_Intensity;
			}
			HandleFadingAnimation(animation_ptr);
			break;
		case LED_ANIMATION_BLINK:
			animation_ptr->Step_Timer = 0;	// Reset the step timer to perform the first step immediately
			// Load Blink specific animation data
			blink_data = (BLINK_PARAMETER_TYPE *)animation_ptr->Parameters;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			blink_data->Duty_Cycle = sf_data[6];
			HandleBlinkAnimation(animation_ptr);
			break;
		case LED_ANIMATION_SEQUENCE:
			// Load Sequence specific animation data
			animation_ptr->Led_Pattern = PATTERN_ALL;
			sequence_data = (SEQUENCE_PARAMETER_TYPE *)animation_ptr->Parameters;	//lint !e927 Suppess Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			sequence_data->Step_Num = sf_data[6];
			sequence_data->Tail_Scaling_Num = GET_HIGH_PARAMETER(sf_data[7]);
			sequence_data->Tail_Step_Num = GET_LOW_PARAMETER(sf_data[7]);
			break;
		default:
			break;
	}

	LoadAnimationNextStep(animation_ptr);	// Load first step
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Lead next animation step
 *    @details 	This method sets the behavior of the next animation step
 *    @param 	*animation_ptr : Pointer to the animation structure
 *    @param 	*sf_data : pointer to read setting file data
 */
static void LoadAnimationNextStep(LED_ANIMATIONS_TYPE * animation_ptr)
{
	float time_ratio;
	BLINK_PARAMETER_TYPE *blink_data;
	SEQUENCE_PARAMETER_TYPE *sequence_data;

	switch(animation_ptr->Animation_Type)
	{
		case LED_ANIMATION_FADING:
			animation_ptr->Step_Timer = animation_ptr->Animation_Period / (LED_PWM_TABLE_SIZE - 1);
			break;
		case LED_ANIMATION_BLINK:
			blink_data = (BLINK_PARAMETER_TYPE *)animation_ptr->Parameters;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			time_ratio = (float)blink_data->Duty_Cycle / 100;	//DT% / 100

			if(animation_ptr->Flags.Direction == 1)	// Led On, next step will be OFF
			{
				time_ratio =  1 - time_ratio;		//Calculate Led OFF ratio
			}
			animation_ptr->Step_Timer = (uint16)((float)animation_ptr->Animation_Period * time_ratio);

			break;
		case LED_ANIMATION_SEQUENCE:
			sequence_data = (SEQUENCE_PARAMETER_TYPE *)animation_ptr->Parameters;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]
			animation_ptr->Step_Timer = animation_ptr->Animation_Period / sequence_data->Step_Num;

			if(animation_ptr->Animation_Status != LED_ANIMATION_PAUSED)	// If the animation is paused, Steps_Rem field shall not be recalculated
			{
				sequence_data->Steps_Rem = sequence_data->Step_Num;
				if(animation_ptr->Flags.Tail_Scroll_To_End == TRUE)	// If tail has to be scrolled to the end, add additional steps
				{
					sequence_data->Steps_Rem = sequence_data->Steps_Rem + sequence_data->Tail_Step_Num;

					// Handle cyclic sequences - When the tail has scrolled to the end, reload remaining steps based on current head led index
					if(animation_ptr->Flags.Cycle_Sequence == TRUE &&
					   animation_ptr->Flags.Reverse == FALSE)	// An animation can't be cycled and reversible at the same time
					{
						sequence_data->Steps_Rem = sequence_data->Steps_Rem - FindNextSequenceHeadLed(animation_ptr);
					}
				}
			}
			break;
		default:
			break;
	}
}
//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Sets the pointed animation to LED_ANIMATION_RUNNING state
 *    @param 	*animation_ptr : Pointer to the animation structure
 */
static void StartAnimation(LED_ANIMATIONS_TYPE * animation_ptr)
{
	animation_ptr->Animation_Status = LED_ANIMATION_RUNNING;
#if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
	animation_ptr->Led_Pattern = HblHmi__SetLedPriorityBuffer(HBLHMI_LED_PRIORITY_LEDANIMATIONMGR, animation_ptr->Led_Group, animation_ptr->Led_Pattern, TRUE);	// Request LEDs priority
#endif

	animation_ptr->Event_Mask.Resume = TRUE;
	ExecuteCallBack(animation_ptr);
	animation_ptr->Event_Mask.Resume = FALSE;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Sets the pointed animation to LED_ANIMATION_IDLE state
 *    @param 	*animation_ptr : Pointer to the animation structure
 */
static void StopAnimation(LED_ANIMATIONS_TYPE * animation_ptr)
{

#if (HBLHMI_LED_PRIORITY_FEATURE == ENABLED)
	animation_ptr->Led_Pattern = HblHmi__SetLedPriorityBuffer(HBLHMI_LED_PRIORITY_LEDANIMATIONMGR, animation_ptr->Led_Group, animation_ptr->Led_Pattern, FALSE);	// Release LEDs priority
#endif

	animation_ptr->Event_Mask.Stop = TRUE;
	ExecuteCallBack(animation_ptr);
	animation_ptr->Animation_Status = LED_ANIMATION_IDLE;
	animation_ptr->Event_Mask.Stop = FALSE;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Fading animations handler
 *    @details 	This method handles fading animations
 *    @param 	*animation_ptr : Pointer to the animation structure
 *    @param 	*sf_data : pointer to read setting file data
 */
static void HandleFadingAnimation(LED_ANIMATIONS_TYPE * animation_ptr)
{
	FADING_PARAMETER_TYPE *fading_data;
	uint8 initial_intensity;
	uint8 final_intensity;
	BOOL_TYPE fading_end;

	fading_data = (FADING_PARAMETER_TYPE *)animation_ptr->Parameters;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

	initial_intensity = fading_data->Initial_Intensity;
	final_intensity = fading_data->Final_Intensity;
	fading_end = FALSE;

	if(animation_ptr->Animation_Status == LED_ANIMATION_RUNNING)
	{
		if(animation_ptr->Flags.Direction == FALSE)	// FadeIn
		{
			if(animation_ptr->Flags.Reverse == FALSE &&	// End of the animation reached and the reverse flag is FALSE
			   fading_data->Current_Intensity	== final_intensity)
			{
				fading_data->Current_Intensity = initial_intensity;	//Reset intensity index
			}
			else
			{
				fading_data->Current_Intensity++;
			}
		}
		else										// FadeOut
		{
			if(animation_ptr->Flags.Reverse == FALSE &&	// End of the animation reached and the reverse flag is FALSE
			   fading_data->Current_Intensity	==  initial_intensity)
			{
				fading_data->Current_Intensity = final_intensity;	//Reset intensity index
			}
			else
			{
				fading_data->Current_Intensity--;
			}
		}
	}

	HblHmi__SetObjectWithPWM(	VISUAL_OBJECT_BAR,
								animation_ptr->Led_Group,
								animation_ptr->Led_Pattern,
								fading_data->Current_Intensity,
								animation_ptr->Pwm_Index,
								HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);

	// If the current intensity index is beyond Final_Intensity target value, then go the the next execution
	if(animation_ptr->Flags.Direction == FALSE)
	{
		if(fading_data->Current_Intensity >= final_intensity)
		{
			fading_end = TRUE;
		}
	}
	else
	{
		if(fading_data->Current_Intensity <= initial_intensity)
		{
			fading_end = TRUE;
		}
	}

	if(fading_end == TRUE)
	{
		animation_ptr->Animation_Status = LED_ANIMATION_EXEC_OVER;
		uint8 animation_index = FindAnimationIndex(animation_ptr->Led_Group,animation_ptr->Led_Pattern);
		if(animation_index != INVALID_VALUE)
		{
			if(animation_ptr->Flags.Reverse == TRUE && Animation_Store_Mgr[animation_index].Is_Reversing == FALSE)
			{
				animation_ptr->Flags.Direction ^= 1;
				Animation_Store_Mgr[animation_index].Is_Reversing = TRUE;
				animation_ptr->Animation_Status = LED_ANIMATION_RUNNING;
			}
			else if(Animation_Store_Mgr[animation_index].Is_Reversing == TRUE)
			{
				Animation_Store_Mgr[animation_index].Is_Reversing = FALSE;
				animation_ptr->Flags.Direction ^= 1;
			}
		}
	}

	LoadAnimationNextStep(animation_ptr);
}
//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Blink animations handler
 *    @details 	This method handles blink animations
 *    @param 	*animation_ptr : Pointer to the animation structure
 */
static void HandleBlinkAnimation(LED_ANIMATIONS_TYPE * animation_ptr)
{
    uint8 animation_index = FindAnimationIndex(animation_ptr->Led_Group,animation_ptr->Led_Pattern);

	if((animation_ptr->Animation_Status == LED_ANIMATION_RUNNING) &&
	   (animation_index != INVALID_VALUE))
	{
		animation_ptr->Flags.Direction ^= 1;	// Switch direction

		if(animation_ptr->Flags.Direction == 1)	// Led should turn ON
		{
		    HblHmi__SetObject(  VISUAL_OBJECT_BAR,
                                animation_ptr->Led_Group,
                                animation_ptr->Led_Pattern,
                                LED_INTENSITY_MAX,
                                HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
		}
		else
		{
		    HblHmi__SetObject(  VISUAL_OBJECT_BAR,
                                animation_ptr->Led_Group,
                                animation_ptr->Led_Pattern,
                                LED_INTENSITY_OFF,
                                HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
		}

		if(Animation_Store_Mgr[animation_index].Is_Reversing == FALSE)
        {
            Animation_Store_Mgr[animation_index].Is_Reversing = TRUE;
            LoadAnimationNextStep(animation_ptr);
        }
        else
        {
            Animation_Store_Mgr[animation_index].Is_Reversing = FALSE;
            animation_ptr->Animation_Status = LED_ANIMATION_EXEC_OVER;  // Next step (and timer) is reloaded in the RunAnimation state machine
        }
	}
}
//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Sequence animations handler
 *    @details 	This method handles sequence animations
 *    @param 	*animation_ptr : Pointer to the animation structure
 *    @param 	*sf_data : pointer to read setting file data
 */
static void HandleSequenceAnimation(LED_ANIMATIONS_TYPE * animation_ptr)
{
	SEQUENCE_PARAMETER_TYPE *sequence_data;
	uint8 intensity_index;
	uint8 packed_led_num;
	uint8 led_num_in_group;
	uint8 steps_amount;
	uint8 current_step;
	uint8 head_led;
	uint8 tail_index;
	uint8 led_index;
	sint8 index;
	sint8 led_offset;
	sint8 bottom_tail_offset;
	ON_OFF_TYPE led_status;

	led_index = 0;

	//TODO: Add support for Led Pattern in sequence animation
	//animation_ptr->Led_Pattern = LED_PATTERN_ANY;	// LED_PATTERN_ANY = 0

	sequence_data = (SEQUENCE_PARAMETER_TYPE *)animation_ptr->Parameters;	//lint !e927 Suppress Info: cast from pointer to pointer [MISRA 2004 Rule 11.4]

	led_num_in_group = HblHmi__GetLedNumInGroup(animation_ptr->Led_Group);	// Get the number of LEDs in selected Led_Group

	steps_amount = sequence_data->Step_Num;
	packed_led_num = led_num_in_group / steps_amount;	// Calculate the number of LEDs to manage together

	if(animation_ptr->Flags.Tail_Scroll_To_End == TRUE)	// If tail has to be scrolled to the end, add additional steps
	{
		steps_amount = steps_amount + sequence_data->Tail_Step_Num;
	}

	current_step = steps_amount - sequence_data->Steps_Rem + 1;	//First step is num 1
	head_led = packed_led_num * current_step;	//First led index is 1
	led_offset = head_led - packed_led_num;		//Offset to LED head pack
	bottom_tail_offset = led_offset - packed_led_num * (1 + sequence_data->Tail_Step_Num);	// Offset to the bottom of the tail

	intensity_index = LED_INTENSITY_MAX;

	if(animation_ptr->Flags.Clear_On_Execution == TRUE && //If a new execution is starting and Clear_On_Execution flag is true then clear all leds in group
	   current_step == 1)
	{
		if(animation_ptr->Led_Pattern == PATTERN_ALL)	// If this animation is not overwriting another one on the same group
		{
			HblHmi__SetObject(	VISUAL_OBJECT_BAR,
								animation_ptr->Led_Group,
								animation_ptr->Led_Pattern,
								0,
								HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
		}
	}

	if(animation_ptr->Flags.Inverse_Animation == TRUE && //If a new execution is starting and Inverse_Animation flag is true toggle all current LEDs status
	   current_step == 1)
	{
		for(index = 0; index < led_num_in_group; index++)
		{
			if((animation_ptr->Led_Pattern & (1 << index)) > 0)	// If current led is included in the animation pattern
			{
				HblHmi__ModifyLedInGroup(animation_ptr->Led_Group,
										 index,
										 ((!HblHmi__GetLedStateInGroup(animation_ptr->Led_Group, index)) << 7),
										 HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
			}
		}
	}

	// Toggle the previous led pack
	for(index = bottom_tail_offset; index < (bottom_tail_offset + packed_led_num); index++)	//Turn off LEDs before the tail offset (outside of the "tail", if we have one)
	{
		if(index >= 0 && (index < led_num_in_group || animation_ptr->Flags.Cycle_Sequence == TRUE))	// Check led index range
		{
			led_index = index;

			// Handle Cycle Sequence flag
			if(index >= led_num_in_group &&
			   animation_ptr->Flags.Cycle_Sequence == TRUE &&
			   animation_ptr->Flags.Reverse == FALSE)	// An animation can't be cycled and reversible at the same time
			{
				led_index = index - led_num_in_group;
			}

			if(animation_ptr->Flags.Direction == TRUE)	// Backward / Counter-clockwise
			{
				led_index = (led_num_in_group - led_index - 1);
			}

			if((animation_ptr->Led_Pattern & (1 << led_index)) > 0)	// If current led is included in the animation pattern
			{
				HblHmi__ModifyLedInGroup(animation_ptr->Led_Group,
										 led_index,
										 ((!HblHmi__GetLedStateInGroup(animation_ptr->Led_Group, led_index)) << 7),
										 HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
			}
		}
	}

	// Toggle the current led pack
	for(index = led_offset; index < head_led; index++)
	{
		if(index >= 0 && (index < led_num_in_group || animation_ptr->Flags.Cycle_Sequence == TRUE))	// Check led index range
		{
			led_index = index;

			// Handle Cycle Sequence flag
			if(index >= led_num_in_group &&
			   animation_ptr->Flags.Cycle_Sequence == TRUE &&
			   animation_ptr->Flags.Reverse == FALSE)	// An animation can't be cycled and reversible at the same time
			{
				led_index = index - led_num_in_group;
			}

			if(animation_ptr->Flags.Direction == TRUE)	// Backward / Counter-clockwise
			{
				led_index = (led_num_in_group - led_index - 1);
			}

			if((animation_ptr->Led_Pattern & (1 << led_index)) > 0)	// If current led is included in the animation pattern
			{
				HblHmi__ModifyLedInGroup(animation_ptr->Led_Group,
										 led_index,
										 ((!HblHmi__GetLedStateInGroup(animation_ptr->Led_Group, led_index)) << 7),
										 HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
			}
		}
	}

	//Tail steps intensity scaling
	if(sequence_data->Tail_Scaling_Num > 0)
	{
		for(tail_index = 0; tail_index < sequence_data->Tail_Step_Num; tail_index++)
		{
			bottom_tail_offset = bottom_tail_offset + packed_led_num;// * (1 + tail_index);	// Adjusting offset to the next tail step

			for(index = bottom_tail_offset; index < (bottom_tail_offset + packed_led_num); index++)
			{
				if(index >= 0 && (index < led_num_in_group || animation_ptr->Flags.Cycle_Sequence == TRUE))	// Check led index range
				{
					led_index = index;

					// Handle Cycle Sequence flag
					if(index >= led_num_in_group &&
					   animation_ptr->Flags.Cycle_Sequence == TRUE &&
					   animation_ptr->Flags.Reverse == FALSE)	// An animation can't be cycled and reversible at the same time
					{
						led_index = index - led_num_in_group;
					}

					if(animation_ptr->Flags.Direction == TRUE)	// Backward / Counter-clockwise
					{
						led_index = (led_num_in_group - led_index - 1);
					}

					if((animation_ptr->Led_Pattern & (1 << led_index)) > 0)	// If current led is included in the animation pattern
					{
						led_status = HblHmi__GetLedStateInGroup(animation_ptr->Led_Group, index);

						if(led_status == ON)
						{
							HblHmi__ModifyLedInGroup(animation_ptr->Led_Group,
											 	 	 led_index,
													 (intensity_index - (sequence_data->Tail_Step_Num - tail_index) * SEQUENCE_TAIL_INTENSITY_STEPS_SCALING),
													 HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
						}
						else
						{
							HblHmi__ModifyLedInGroup(animation_ptr->Led_Group,
											 	 	 led_index,
													 	 (LED_INTENSITY_OFF + (sequence_data->Tail_Step_Num - tail_index) * SEQUENCE_TAIL_INTENSITY_STEPS_SCALING),
														 HBLHMI_LED_PRIORITY_LEDANIMATIONMGR);
						}
					}
				}
			}
		}
	}

	//After animation handling
	if(animation_ptr->Animation_Status == LED_ANIMATION_RUNNING)
	{
		if(sequence_data->Steps_Rem > 0)
		{
			sequence_data->Steps_Rem--;
			animation_ptr->Step_Timer = animation_ptr->Animation_Period / sequence_data->Step_Num;
		}
		else
		{
			if(animation_ptr->Flags.Reverse == TRUE)
			{
				animation_ptr->Flags.Direction ^= 1;
			}
			animation_ptr->Animation_Status = LED_ANIMATION_EXEC_OVER;
		}
	}
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Search animation index of a given led_group and led_index combo.
 *    @details 	This method returns the animation index of a given led_group and led_pattern combo
 *    @param 	led_group: Led Group of the animation you're looking for
 *    @param 	led_pattern: Led Pattern of the animation you're looking for
 *    @return	ret_val: The index of the given animation
 */
static uint8 FindAnimationIndex(uint8 led_group, uint32 led_pattern)
{
	uint8 index;
    uint8 ret_val;

    ret_val = INVALID_VALUE;

    for(index = 0; index < MAX_ACTIVE_ANIMATIONS; index++)
    {
        if ((Animation_Store_Mgr[index].Led_Group == led_group) &&
            (Animation_Store_Mgr[index].Animation_Status != LED_ANIMATION_IDLE))
        {
        	if(led_pattern != LED_PATTERN_ANY)
        	{
            	// Fading and blinking animations also need to match the led_pattern
            	if(Animation_Store_Mgr[index].Animation_Type == LED_ANIMATION_FADING)
    			{
            		if(Animation_Store_Mgr[index].Led_Pattern != led_pattern)
            		{
            			continue;
            		}
    			}
            	else if(Animation_Store_Mgr[index].Animation_Type == LED_ANIMATION_BLINK)
    			{
            		if(Animation_Store_Mgr[index].Led_Pattern != led_pattern)
            		{
            			continue;
            		}
    			}

            	ret_val = index;
        	}

        	break;
        }
    }

    return ret_val;
}

//---------------------------------------------------------------------------------------------------------------------
/**
 *    @brief 	Find the next head led of a sequence animation
 *    @param 	*animation_ptr : Pointer to the animation structure
 *    @return 	led_index : index of the head led in the animated led group
 */
static uint8 FindNextSequenceHeadLed(LED_ANIMATIONS_TYPE * animation_ptr)
{
	uint8 led_num_in_group;
	uint8 led_index;
	BOOL_TYPE bottom_led_found;
	ON_OFF_TYPE led_status;
	ON_OFF_TYPE led_active_status;

	led_index = 0;
	bottom_led_found = FALSE;
	led_num_in_group = HblHmi__GetLedNumInGroup(animation_ptr->Led_Group);	// Get the number of LEDs in selected Led_Group

	// Head led might by ON or OFF depending on Inverse_Animation flag
	if(animation_ptr->Flags.Inverse_Animation == FALSE)
	{
		led_active_status = ON;
	}
	else
	{
		led_active_status = OFF;
	}

	for(led_index = 0; led_index < led_num_in_group; led_index++)
	{
		if(animation_ptr->Flags.Direction == FALSE)	// Forward / Clockwise
		{
			led_status = HblHmi__GetLedStateInGroup(animation_ptr->Led_Group, led_index);
		}
		else										// Backward / Counterclockwise
		{
			led_status = HblHmi__GetLedStateInGroup(animation_ptr->Led_Group, (led_num_in_group - led_index - 1));
		}

		if(led_status == led_active_status)			// Ensure to be inside the led sequence before looking for the head led
		{
			bottom_led_found = TRUE;
		}
		else if(bottom_led_found == TRUE)
		{
			break;									// Current head led index is id head index + 1. Return this value, as we're loocking for the incoming head led index
		}
	}

	if(bottom_led_found == FALSE)
	{
		led_index = 0;								// If has not be found, head index is 0
	}

	return led_index;

}

#if LED_ANIMATION_SYNC_BLINK == ENABLED
//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Sync given blink animation with other same ID animation in running
 * @param   LED_ANIMATIONS_TYPE * animation_ptr
 */
static void SyncBlinkAnimation(LED_ANIMATIONS_TYPE * animation_ptr)
{
    uint8 index;
    if (animation_ptr->Animation_Type == LED_ANIMATION_BLINK)
    {
        // Check for other running blink animation with same ID
        for(index = 0; index < MAX_ACTIVE_ANIMATIONS; index++)
        {
            if ((Animation_Store_Mgr[index].Animation_Index == animation_ptr->Animation_Index) &&
            (Animation_Store_Mgr[index].Animation_Status == LED_ANIMATION_RUNNING))
            {
                // Take timer and direction to sync with other animation
                animation_ptr->Step_Timer = Animation_Store_Mgr[index].Step_Timer;
                animation_ptr->Flags.Direction = Animation_Store_Mgr[index].Flags.Direction;
                break;
            }
        }
    }
}
#endif

//---------------------------------------------------------------------------------------------------------------------
/**
 * @brief   Executes a callback when an animation generates an event
 * @param   LED_ANIMATIONS_TYPE * animation_ptr
 */
static void ExecuteCallBack(LED_ANIMATIONS_TYPE * animation_ptr)
{
	uint8 animation_store_index;

	animation_store_index = FindAnimationIndex(animation_ptr->Led_Group, animation_ptr->Led_Pattern);

    Callback__Notify(&LedAnimationMgr_Callback_Control_Structure, (CALLBACK_EVENT_TYPE)animation_store_index);
}
